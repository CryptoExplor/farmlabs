<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Script Console: Transaction Farming</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f4f1eb; /* Warm Beige */
            color: #212529; /* Dark Gray for infographic text */
        }
        /* Console specific styles */
        .bg-primary { background-color: #f4f1eb; }
        .bg-secondary { background-color: #ffffff; }
        .text-main { color: #2d3748; } /* Slate 800 */
        .text-accent { color: #4a5568; } /* Slate 600 */
        .border-accent { border-color: #e2e8f0; } /* Slate 200 */
        .btn-primary { background-color: #3b82f6; color: white; }
        .btn-primary:hover { background-color: #2563eb; }
        .btn-secondary { background-color: #6b7280; color: white; }
        .btn-secondary:hover { background-color: #4b5563; }
        .btn-danger { background-color: #ef4444; color: white; }
        .btn-danger:hover { background-color: #dc2626; }
        .btn-success { background-color: #22c55e; color: white; }
        .btn-success:hover { background-color: #16a34a; }
        .btn-llm { background-color: #e0f2fe; color: #0284c7; } /* Light blue for LLM buttons */
        .btn-llm:hover { background-color: #bae6fd; }

        .nav-link {
            transition: all 0.3s ease;
            border-bottom: 2px solid transparent;
        }
        .nav-link:hover, .nav-link.active {
            color: #3b82f6;
            border-bottom-color: #3b82f6;
        }
        /* Chart container for console charts */
        #script-console-content .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 40vh;
        }
        @media (min-width: 768px) {
            #script-console-content .chart-container {
                height: 350px;
            }
        }
        #live-log {
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .log-success { color: #22c55e; }
        .log-error { color: #ef4444; }
        .log-info { color: #3b82f6; }
        .log-warning { color: #f59e0b; }
        .log-skipped { color: #a8a29e; }
        .log-copy-btn {
            background: none;
            border: none;
            color: #a8a29e; /* Gray */
            cursor: pointer;
            font-size: 0.8em;
            margin-left: 5px;
            padding: 0 3px;
            vertical-align: middle;
            transition: color 0.2s;
        }
        .log-copy-btn:hover {
            color: #e2e8f0; /* Lighter gray on hover */
        }


        .tooltip-container {
            position: relative;
            display: inline-block;
        }

        .tooltip-container .tooltip-text {
            visibility: hidden;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%; /* Position above the text */
            left: 50%;
            margin-left: -75px; /* Center the tooltip */
            opacity: 0;
            transition: opacity 0.3s;
            width: 150px;
        }

        .tooltip-container .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%; /* At the bottom of the tooltip */
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }

        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            position: relative;
        }
        .close-button, .close-qr-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-button:hover,
        .close-button:focus,
        .close-qr-button:hover,
        .close-qr-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .modal-loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Disabled styles for fields */
        .wallet-feature-control:disabled,
        .wallet-feature-control[disabled] {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: #e2e8f0; /* Light gray */
        }

        /* Infographic specific styles from original infographic html */
        #infographic-content {
            background-color: #F8F9FA;
            color: #212529;
        }
        #infographic-content .chart-container {
            position: relative;
            width: 100%;
            margin-left: auto;
            margin-right: auto;
            max-width: 600px;
            height: 320px;
        }
        @media (min-width: 768px) {
            #infographic-content .chart-container {
                height: 400px;
            }
        }
        .kpi-card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            padding: 1.5rem;
            text-align: center;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .kpi-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .flowchart-step {
            border: 2px solid #90E0EF;
            background-color: white;
            border-radius: 0.75rem; /* Added rounded corners for flowchart steps */
        }
        .flowchart-arrow {
            color: #0077B6;
        }
    </style>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>
<body class="bg-primary text-main">

    <header class="bg-secondary shadow-md sticky top-0 z-10">
        <div class="container mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <h1 class="text-xl md:text-2xl font-bold text-main">Interactive Script Console</h1>
                <nav class="hidden md:flex items-center space-x-8">
                    <a href="#dashboard" class="nav-link text-accent font-medium pb-1 active" data-page="console">Dashboard</a>
                    <a href="#wallets" class="nav-link text-accent font-medium pb-1" data-page="console">Wallets</a>
                    <a href="#recipient-settings" class="nav-link text-accent font-medium pb-1" data-page="console">Recipients</a>
                    <a href="#config" class="nav-link text-accent font-medium pb-1" data-page="console">Configuration</a>
                    <a href="#log" class="nav-link text-accent font-medium pb-1" data-page="console">Live Log</a>
                    <a href="#overview" class="nav-link text-accent font-medium pb-1" data-page="infographic">Infographic</a>
                </nav>
            </div>
        </div>
    </header>

    <main class="container mx-auto p-4 sm:p-6 lg:p-8">
        <h2 class="text-3xl md:text-4xl font-extrabold text-center mb-6" style="color: #0077B6;">Farm smarter, not harder — with FarmLabs.</h2>

        <!-- Script Console Content -->
        <div id="script-console-content">
            <div id="security-warning" class="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-8 rounded-r-lg" role="alert">
                <p class="font-bold">Security Warning</p>
                <p>Pasting your private keys or sensitive contract ABIs into a website is extremely risky and can result in loss of funds. This application is a client-side tool for demonstration purposes only. Use it with test keys and on test networks. Never use it with mainnet keys holding real assets.</p>
            </div>

            <!-- Dashboard Section -->
            <section id="dashboard" class="mb-12">
                <h2 class="text-3xl font-bold mb-2 text-main">Dashboard</h2>
                <p class="text-accent mb-6">Start, stop, and monitor the transaction farming process from here, with real-time updates on wallet balances and action distribution.</p>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                    <div class="bg-secondary p-6 rounded-lg shadow-md flex flex-col items-center justify-center space-y-4">
                        <button id="connect-wallet-btn" class="w-full py-3 px-4 rounded-lg font-semibold transition-all duration-300 btn-success">🔗 Connect Wallet</button>
                        <div id="wallet-status-display" class="text-center text-sm font-medium text-main">
                            No wallet connected.
                        </div>
                        <button id="start-btn" class="w-full py-3 px-4 rounded-lg font-semibold transition-all duration-300 btn-primary wallet-feature-control" disabled>▶️ Start Farming</button>
                        <button id="stop-btn" class="w-full py-3 px-4 rounded-lg font-semibold transition-all duration-300 btn-danger wallet-feature-control" disabled>⏹️ Stop Farming</button>
                        <button id="clear-all-data-btn" class="w-full py-2 px-4 rounded-lg font-semibold transition-all duration-300 btn-secondary wallet-feature-control" disabled>🗑️ Clear All Data</button>
                    </div>
                     <div class="bg-secondary p-6 rounded-lg shadow-md col-span-1 md:col-span-2">
                        <h3 class="font-bold text-lg mb-4 text-main">Live Status</h3>
                        <div class="space-y-4">
                            <div>
                                <div class="flex justify-between items-center mb-1">
                                    <span class="text-sm font-medium text-accent">Total Actions Performed</span>
                                    <span id="progress-text" class="text-sm font-medium text-accent">0</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-4">
                                    <div id="progress-bar" class="bg-blue-500 h-4 rounded-full transition-all duration-500" style="width: 0%"></div>
                                </div>
                            </div>
                            <div class="grid grid-cols-2 sm:grid-cols-4 gap-4 text-center">
                                <div class="p-3 bg-blue-50 rounded-lg">
                                    <div class="text-xs text-blue-500 font-bold uppercase">Status</div>
                                    <div id="status-display" class="text-lg font-semibold text-main">Idle</div>
                                </div>
                                <div class="p-3 bg-green-50 rounded-lg">
                                    <div class="text-xs text-green-500 font-bold uppercase">Successful Actions</div>
                                    <div id="success-count" class="text-lg font-semibold text-main">0</div>
                                </div>
                                <div class="p-3 bg-red-50 rounded-lg">
                                    <div class="text-xs text-red-500 font-bold uppercase">Failed Actions</div>
                                    <div id="fail-count" class="text-lg font-semibold text-main">0</div>
                                </div>
                                <div class="p-3 bg-gray-100 rounded-lg">
                                    <div class="text-xs text-gray-500 font-bold uppercase">Current Gas</div>
                                    <div id="gas-display" class="text-lg font-semibold text-main">N/A</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <div class="bg-secondary p-6 rounded-lg shadow-md lg:col-span-2">
                        <h3 class="font-bold text-lg mb-4 text-main">Wallet Balances (ETH)</h3>
                        <p class="text-sm text-accent mb-4">This chart shows the current balance of each loaded wallet, dynamically updating after transactions.</p>
                        <div class="chart-container">
                            <canvas id="wallet-balance-chart"></canvas>
                        </div>
                    </div>
                    <div class="bg-secondary p-6 rounded-lg shadow-md">
                        <h3 class="font-bold text-lg mb-4 text-main">Action Distribution</h3>
                        <p class="text-sm text-accent mb-4">Visualizes the types of actions performed (send, idle).</p>
                        <div class="chart-container">
                            <canvas id="action-dist-chart"></canvas>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Wallet Section -->
            <section id="wallets" class="mb-12">
                <h2 class="text-3xl font-bold mb-2 text-main">Wallets</h2>
                <p class="text-accent mb-6">Load your source wallets by pasting private keys below. Ensure you have sufficient balance for transactions.</p>
                <div class="bg-secondary p-8 rounded-lg shadow-md mb-8">
                    <div class="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-3 mb-4 rounded-r-lg" role="alert">
                        <p class="font-bold text-sm">Important Security Reminder:</p>
                        <p class="text-xs italic">Only use test keys on testnets for this application. Never use mainnet private keys holding real funds.</p>
                    </div>
                    <label for="private-keys" class="block font-medium mb-1 text-accent">Private Keys (one per line)</label>
                    <textarea id="private-keys" rows="5" class="w-full p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition font-mono text-sm wallet-feature-control" disabled></textarea>
                    <button id="load-keys-btn" class="mt-4 w-full py-2 px-4 rounded-lg font-semibold transition-all duration-300 btn-secondary wallet-feature-control" disabled>Load Wallets & Check Balances</button>
                    <p id="keys-loaded-count" class="text-sm text-green-600 mt-2 font-medium"></p>
                </div>

                <h3 class="text-2xl font-bold mb-2 text-main">Loaded Wallets</h3>
                <p class="text-accent mb-6">Overview of all wallets currently loaded in the application.</p>
                <div class="bg-secondary p-6 rounded-lg shadow-md">
                    <ul id="wallet-list-display" class="list-disc pl-5 space-y-2 text-sm text-accent">
                        <li id="no-wallets-msg">No wallets loaded yet.</li>
                    </ul>
                </div>
            </section>

            <!-- Recipient Section - Kept separate for clarity on dynamic scanning -->
            <section id="recipient-settings" class="mb-12">
                <h2 class="text-3xl font-bold mb-2 text-main">Recipient Settings</h2>
                <p class="text-accent mb-6">Choose how the script will select destination addresses for transactions.</p>
                <div class="bg-secondary p-8 rounded-lg shadow-md">
                    <div class="space-y-4">
                        <label class="flex items-center">
                            <input type="radio" name="recipient-mode" value="pool" class="form-radio h-5 w-5 text-blue-600 wallet-feature-control" checked disabled>
                            <span class="ml-3 text-main">Use Dynamically Scanned Pool</span>
                        </label>
                        <label class="flex items-center">
                            <input type="radio" name="recipient-mode" value="fixed" class="form-radio h-5 w-5 text-blue-600 wallet-feature-control" disabled>
                            <span class="ml-3 text-main">Use Fixed Address</span>
                        </label>
                        <label class="flex items-center">
                            <input type="radio" name="recipient-mode" value="list" class="form-radio h-5 w-5 text-blue-600 wallet-feature-control" disabled>
                            <span class="ml-3 text-main">Use Custom List of Addresses (one per line)</span>
                        </label>
                        <label class="flex items-center">
                            <input type="radio" name="recipient-mode" value="predefined" class="form-radio h-5 w-5 text-blue-600 wallet-feature-control" disabled>
                            <span class="ml-3 text-main">Use Predefined List of Addresses (from CSV)</span>
                        </label>
                        <label class="flex items-center">
                            <input type="radio" name="recipient-mode" value="self-interact" class="form-radio h-5 w-5 text-blue-600 wallet-feature-control" disabled>
                            <span class="ml-3 text-main">Use Loaded Wallets to Interact with Each Other</span>
                        </label>
                    </div>

                    <div id="fixed-address-section" class="mt-4 hidden">
                        <label for="fixed-address" class="block font-medium mb-1 text-accent">Fixed Recipient Address</label>
                        <input type="text" id="fixed-address" class="w-full p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition font-mono text-sm wallet-feature-control" placeholder="0x..." disabled>
                    </div>

                    <div id="list-addresses-section" class="mt-4 hidden">
                        <label for="list-addresses" class="block font-medium mb-1 text-accent">Recipient Addresses (one per line)</label>
                        <textarea id="list-addresses" rows="5" class="w-full p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition font-mono text-sm wallet-feature-control" placeholder="0x...&#10;0x...&#10;... (one address per line)" disabled></textarea>
                        <button id="load-addresses-from-list-btn" class="mt-4 w-full py-2 px-4 rounded-lg font-semibold transition-all duration-300 btn-secondary wallet-feature-control" disabled>Load Addresses from List</button>
                        <p id="list-addresses-count" class="text-sm text-green-600 mt-2 font-medium"></p>
                    </div>

                    <div id="predefined-addresses-section" class="mt-4 hidden">
                        <p class="block font-medium mb-1 text-accent">Download list here:</p>
                        <ul class="list-disc pl-5 mb-4 text-sm text-blue-700">
                            <li><a href="https://d.cess.network/n1/812192221.csv" target="_blank" class="hover:underline">Link 1 (recipients1)</a></li>
                            <li><a href="https://d.cess.network/n1/1394676302.csv" target="_blank" class="hover:underline">Link 2 (recipients2)</a></li>
                            <li><a href="https://d.cess.network/n1/1338053122.csv" target="_blank" class="hover:underline">Link 3 (recipients3)</a></li>
                            <li><a href="https://d.cess.network/n1/738595260.csv" target="_blank" class="hover:underline">Link 4 (recipients4)</a></li>
                            <li><a href="https://d.cess.network/n1/1213534582.csv" target="_blank" class="hover:underline">Link 5 (recipients5)</a></li>
                            <li><a href="https://d.cess.network/n1/1210782270.csv" target="_blank" class="hover:underline">Link 6 (recipients6)</a></li>
                            <li><a href="https://d.cess.network/n1/1179652688.csv" target="_blank" class="hover:underline">Link 7 (recipients7)</a></li>
                            <li><a href="https://d.cess.network/n1/645402960.csv" target="_blank" class="hover:underline">Link 8 (recipients8)</a></li>
                            <li><a href="https://d.cess.network/n1/1006375340.csv" target="_blank" class="hover:underline">Link 9 (recipients9)</a></li>
                            <li><a href="https://d.cess.network/n1/1249120790.csv" target="_blank" class="hover:underline">Link 10 (recipients10)</a></li>
                            <li><a href="https://d.cess.network/n1/892015044.csv" target="_blank" class="hover:underline">Link 11 (recipients11)</a></li>
                            <li><a href="https://d.cess.network/n1/1174737402.csv" target="_blank" class="hover:underline">Link 12 (recipients12)</a></li>
                        </ul>

                        <label for="predefined-file-input" class="block font-medium mb-1 text-accent">Or Upload Your Own Predefined List (CSV)</label>
                        <input type="file" id="predefined-file-input" accept=".csv" class="w-full p-2 border border-accent rounded-md mb-2 wallet-feature-control" disabled>
                        <button id="load-predefined-file-btn" class="mt-2 w-full py-2 px-4 rounded-lg font-semibold transition-all duration-300 btn-secondary wallet-feature-control" disabled>Load Predefined Addresses from CSV</button>
                        <p id="predefined-addresses-info" class="text-sm text-gray-500 mt-1">No file loaded.</p>
                        <ul id="predefined-addresses-display" class="list-disc pl-5 space-y-1 text-sm text-accent max-h-32 overflow-y-auto mt-2">
                            <!-- Predefined addresses will be populated here -->
                        </ul>
                        <p id="predefined-addresses-count" class="text-sm text-green-600 mt-2 font-medium"></p>
                    </div>
                </div>
            </section>

            <!-- Configuration Section -->
            <section id="config" class="mb-12">
                <h2 class="text-3xl font-bold mb-2 text-main">Configuration</h2>
                <p class="text-accent mb-6">Define the parameters for the transaction farming, including network settings, amounts, delays, and gas thresholds.</p>

                <!-- Main configuration grid container -->
                <div class="bg-secondary p-8 rounded-lg shadow-md grid grid-cols-1 md:grid-cols-2 gap-8">
                    <!-- Individual configuration items -->
                    <div>
                        <label for="max-txns-per-wallet" class="block font-medium mb-1 text-accent">Max Actions Per Wallet Session
                            <span class="tooltip-container ml-1 text-gray-400 cursor-pointer">ℹ️<span class="tooltip-text">The maximum number of distinct actions (send, idle, balance check) a single wallet will attempt in its session on a given blockchain network. The actual number of actions will be randomized up to this maximum.</span></span>
                        </label>
                        <input type="number" id="max-txns-per-wallet" value="3" class="w-full p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition wallet-feature-control" disabled>
                        <p class="text-sm text-gray-500 mt-1">Maximum actions a single wallet will perform in its session on a given chain.</p>
                    </div>
                    <div>
                        <label for="wallet-idle-chance" class="block font-medium mb-1 text-accent">Wallet Idle Chance (%)
                            <span class="tooltip-container ml-1 text-gray-400 cursor-pointer">ℹ️<span class="tooltip-text">The percentage chance that a specific wallet will be "idle" for an entire session on a chain, meaning it will perform no actions. This simulates unpredictable human-like behavior.</span></span>
                        </label>
                        <input type="number" id="wallet-idle-chance" value="25" min="0" max="100" class="w-full p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition wallet-feature-control" disabled>
                        <p class="text-sm text-gray-500 mt-1">Chance for a wallet to be idle and skip its session on a chain.</p>
                    </div>
                    <div>
                        <label for="gas-multiplier" class="block font-medium mb-1 text-accent">Max Gas Price Multiplier
                            <span class="tooltip-container ml-1 text-gray-400 cursor-pointer">ℹ️<span class="tooltip-text">If the current gas price on the network exceeds the average gas price by this multiplier, the script will temporarily pause activities for that wallet on that chain to avoid high fees.</span></span>
                        </label>
                        <input type="number" id="gas-multiplier" value="2" step="0.1" class="w-full p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition wallet-feature-control" disabled>
                        <p class="text-sm text-gray-500 mt-1">Skip wallet activity if current gas price exceeds average by this multiplier.</p>
                    </div>
                    <!-- NEW: Min Gas Factor -->
                    <div>
                        <label for="min-gas-factor" class="block font-medium mb-1 text-accent">Min Gas Factor (x)
                            <span class="tooltip-container ml-1 text-gray-400 cursor-pointer">ℹ️<span class="tooltip-text">A random factor (between this min and Max Gas Factor) will be applied to the calculated gas price/priority fee to introduce variance.</span></span>
                        </label>
                        <input type="number" id="min-gas-factor" value="0.9" step="0.01" class="w-full p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition wallet-feature-control" disabled>
                        <p class="text-sm text-gray-500 mt-1">Minimum factor for random gas price/priority fee adjustment.</p>
                    </div>
                    <!-- NEW: Max Gas Factor -->
                    <div>
                        <label for="max-gas-factor" class="block font-medium mb-1 text-accent">Max Gas Factor (x)
                            <span class="tooltip-container ml-1 text-gray-400 cursor-pointer">ℹ️<span class="tooltip-text">A random factor (between Min Gas Factor and this max) will be applied to the calculated gas price/priority fee to introduce variance.</span></span>
                        </label>
                        <input type="number" id="max-gas-factor" value="1.1" step="0.01" class="w-full p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition wallet-feature-control" disabled>
                        <p class="text-sm text-gray-500 mt-1">Maximum factor for random gas price/priority fee adjustment.</p>
                    </div>
                    <div>
                        <label for="block-lookback" class="block font-medium mb-1 text-accent">Blocks to Scan for Addresses
                            <span class="tooltip-container ml-1 text-gray-400 cursor-pointer">ℹ️<span class="tooltip-text">The number of recent blockchain blocks the script will scan to find and add new potential recipient addresses to its pool. A higher number means more discovery but takes longer.</span></span>
                        </label>
                        <input type="number" id="block-lookback" value="100" min="10" max="1000" class="w-full p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:focus:border-blue-500 transition wallet-feature-control" disabled>
                        <p class="text-sm text-gray-500 mt-1">Number of recent blocks to scan for new recipient addresses.</p>
                    </div>

                    <!-- NEW: Probability Jitter Factor -->
                    <div>
                        <label for="prob-jitter-factor" class="block font-medium mb-1 text-accent">Probability Jitter Factor (%)
                            <span class="tooltip-container ml-1 text-gray-400 cursor-pointer">ℹ️<span class="tooltip-text">A percentage range (e.g., 5 for ±5%) within which each wallet's action probabilities (Send, Idle, Balance Check) will randomly vary from the global configured probabilities. Set to 0 for no jitter.</span></span>
                        </label>
                        <input type="number" id="prob-jitter-factor" value="5" min="0" max="50" step="1" class="w-full p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition wallet-feature-control" disabled>
                        <p class="text-sm text-gray-500 mt-1">Random variation applied to each wallet's action probabilities.</p>
                    </div>
                    <!-- NEW: Simulated Error Chance -->
                    <div>
                        <label for="simulated-error-chance" class="block font-medium mb-1 text-accent">Simulated Transaction Error Chance (%)
                            <span class="tooltip-container ml-1 text-gray-400 cursor-pointer">ℹ️<span class="tooltip-text">The percentage chance that a 'send' transaction will randomly fail, mimicking network errors. The script will then retry with exponential backoff. Set to 0 to disable.</span></span>
                        </label>
                        <input type="number" id="simulated-error-chance" value="0" min="0" max="100" step="1" class="w-full p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition wallet-feature-control" disabled>
                        <p class="text-sm text-gray-500 mt-1">Chance for a transaction to randomly fail (simulated).</p>
                    </div>

                    <!-- Transaction Amount Range (spans 2 columns on medium screens and up) -->
                    <div class="md:col-span-2">
                        <label class="block font-medium mb-1 text-accent">Transaction Amount Range (ETH)
                            <span class="tooltip-container ml-1 text-gray-400 cursor-pointer">ℹ️<span class="tooltip-text">When a 'send' action is chosen, a random amount of ETH will be sent within this specified minimum and maximum range.</span></span>
                        </label>
                        <div class="flex items-center space-x-4">
                            <!-- Using flex-1 to ensure inputs share space equally within the flex container -->
                            <input type="number" id="min-amount" value="0.0001" step="0.0001" class="flex-1 p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition wallet-feature-control" disabled>
                            <span class="text-gray-500">to</span>
                            <input type="number" id="max-amount" value="0.0002" step="0.0001" class="flex-1 p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition wallet-feature-control" disabled>
                        </div>
                         <p class="text-sm text-gray-500 mt-1">A random ETH amount within this range will be sent for 'send' actions.</p>
                         <button id="explain-send-tx-btn" class="mt-4 py-2 px-4 rounded-lg font-semibold transition-all duration-300 btn-llm wallet-feature-control" disabled>✨ Explain Send Tx</button>
                    </div>

                    <!-- Delay Between Actions (spans 2 columns on medium screens and up) -->
                    <div class="md:col-span-2">
                        <label class="block font-medium mb-1 text-accent">Delay Between Actions (seconds)
                            <span class="tooltip-container ml-1 text-gray-400 cursor-pointer">ℹ️<span class="tooltip-text">After each action (send, idle, balance check), the script will pause for a random duration, sampled from a log-normal distribution, within this minimum and maximum second range.</span></span>
                        </label>
                        <div class="flex items-center space-x-4">
                            <!-- Using flex-1 to ensure inputs share space equally within the flex container -->
                            <input type="number" id="min-delay" value="10" class="flex-1 p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition wallet-feature-control" disabled>
                            <span class="text-gray-500">to</span>
                            <input type="number" id="max-delay" value="30" class="flex-1 p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition wallet-feature-control" disabled>
                        </div>
                        <p class="text-sm text-gray-500 mt-1">A log-normal random delay will be applied after each action.</p>
                    </div>

                    <!-- RPC Endpoints & Chain IDs (spans 2 columns on medium screens and up) -->
                    <div class="md:col-span-2">
                        <label class="block font-medium mb-1 text-accent">RPC Endpoints & Chain IDs (Format: URL,ChainID - one per line)
                            <span class="tooltip-container ml-1 text-gray-400 cursor-pointer">ℹ️<span class="tooltip-text">List the RPC URLs for the blockchain networks you want to interact with, followed by their corresponding Chain ID (e.g., 'https://mainnet.infura.io/v3/YOUR_ID,1'). The script will cycle through these networks.</span></span>
                        </label>
                        <textarea id="rpc-urls" rows="4" class="w-full p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition wallet-feature-control" disabled>https://mainnet.infura.io/v3/YOUR_PROJECT_ID,1
https://rpc.goerli.dev,5</textarea>
                        <p class="text-sm text-gray-500 mt-1">The script will cycle through these RPCs and chains.</p>
                        <button id="test-rpc-btn" class="mt-4 py-2 px-4 rounded-lg font-semibold transition-all duration-300 btn-secondary wallet-feature-control" disabled>⚡ Test RPC Connections</button>
                    </div>

                    <!-- Action Probability Matrix (spans 2 columns on medium screens and up, contains its own grid) -->
                    <div class="md:col-span-2">
                        <h3 class="font-bold text-lg mb-4 text-main">Action Probability Matrix (%)</h3>
                        <p class="text-sm text-accent mb-4">Define the percentage chance for each action type. Must sum to 100.</p>
                        <div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
                            <div>
                                <label for="prob-send" class="block font-medium mb-1 text-accent">Send</label>
                                <input type="number" id="prob-send" value="60" min="0" max="100" class="w-full p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition prob-input wallet-feature-control" disabled>
                            </div>
                            <div>
                                <label for="prob-idle-action" class="block font-medium mb-1 text-accent">Idle Action</label>
                                <input type="number" id="prob-idle-action" value="20" min="0" max="100" class="w-full p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition prob-input wallet-feature-control" disabled>
                            </div>
                            <div>
                                <label for="prob-balance-check" class="block font-medium mb-1 text-accent">Balance Check</label>
                                <input type="number" id="prob-balance-check" value="20" min="0" max="100" class="w-full p-2 border border-accent rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition prob-input wallet-feature-control" disabled>
                            </div>
                        </div>
                        <p id="prob-sum-warning" class="text-sm text-red-500 mt-2 hidden">Probabilities must sum to 100%!</p>
                    </div>
                </div>
            </section>


            <!-- Live Log Section -->
            <section id="log">
                 <h2 class="text-3xl font-bold mb-2 text-main">Live Log</h2>
                 <p class="text-accent mb-6">Real-time output from the transaction farming process will appear below. You can also download the complete log.</p>
                <div class="bg-gray-800 text-white rounded-lg shadow-md p-4 h-96 overflow-y-auto mb-4">
                    <div id="live-log"></div>
                </div>
                <button id="download-log-btn" class="py-2 px-4 rounded-lg font-semibold transition-all duration-300 btn-success wallet-feature-control" disabled>⬇️ Download Log (CSV)</button>
            </section>
        </div><!-- End script-console-content -->

        <!-- Infographic Content -->
        <div id="infographic-content" class="hidden">
            <!-- Section 1: Introduction & Hook -->
            <section id="infographic-overview" class="text-center my-12 md:my-16">
                <h2 class="text-4xl md:text-5xl font-extrabold mb-4" style="color: #0077B6;">Anatomy of an Automated Transaction Farming Script</h2>
                <p class="text-lg md:text-xl text-gray-600 max-w-3xl mx-auto mb-12">
                    A deep dive into a client-side tool designed to automate blockchain interactions for testnet farming, airdrop eligibility, and protocol testing, with a focus on simulating organic, human-like activity.
                </p>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-8 max-w-4xl mx-auto">
                    <div class="kpi-card">
                        <span class="text-5xl font-bold block mb-2" style="color: #00B4D8;">5</span>
                        <h3 class="text-xl font-semibold text-gray-700">Recipient Modes</h3>
                        <p class="text-gray-500 mt-2">From dynamic address pools to self-interaction, offering diverse targeting strategies.</p>
                    </div>
                    <div class="kpi-card">
                        <span class="text-5xl font-bold block mb-2" style="color: #00B4D8;">5+</span>
                        <h3 class="text-xl font-semibold text-gray-700">Randomization Factors</h3>
                        <p class="text-gray-500 mt-2">Simulates human behavior by randomizing amounts, delays, wallets, chains, and gas fees.</p>
                    </div>
                    <div class="kpi-card">
                        <span class="text-5xl font-bold block mb-2" style="color: #00B4D8;">∞</span>
                        <h3 class="text-xl font-semibold text-gray-700">Supported Wallets</h3>
                        <p class="text-gray-500 mt-2">Load an unlimited number of private keys to scale your operations effortlessly.</p>
                    </div>
                </div>
            </section>

            <!-- Section 2: The Core Engine -->
            <section id="infographic-how-it-works" class="my-16 md:my-24">
                <h2 class="text-3xl md:text-4xl font-bold text-center mb-12" style="color: #0077B6;">The Core Engine: How It Works</h2>
                <p class="text-lg text-center text-gray-600 max-w-3xl mx-auto mb-12">
                    The script follows a logical, configurable flow to execute its tasks. From initialization to the final transaction, each step is designed for automation and control.
                </p>
                <div class="flex flex-col items-center space-y-4">
                    <div class="flowchart-step p-4 rounded-lg w-full md:w-1/2 text-center font-semibold">1. Connect & Load Wallets</div>
                    <div class="text-4xl flowchart-arrow">↓</div>
                    <div class="flowchart-step p-4 rounded-lg w-full md:w-1/2 text-center font-semibold">2. Configure Settings (Recipients, Delays, Amounts)</div>
                    <div class="text-4xl flowchart-arrow">↓</div>
                    <div class="flowchart-step p-4 rounded-lg w-full md:w-1/2 text-center font-semibold">3. Start Farming Process</div>
                    <div class="text-4xl flowchart-arrow">↓</div>
                    <div class="flowchart-step p-6 rounded-lg w-full md:w-2/3 text-center border-dashed">
                        <h4 class="font-bold text-lg mb-4">4. Execution Loop (Repeats)</h4>
                        <div class="flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-4">
                            <div class="font-semibold">Select Chain</div>
                            <div class="text-2xl flowchart-arrow hidden md:block">→</div>
                            <div class="text-2xl flowchart-arrow md:hidden">↓</div>
                            <div class="font-semibold">Select Wallet</div>
                            <div class="text-2xl flowchart-arrow hidden md:block">→</div>
                            <div class="text-2xl flowchart-arrow md:hidden">↓</div>
                            <div class="font-semibold">Choose Action</div>
                            <div class="text-2xl flowchart-arrow hidden md:block">→</div>
                            <div class="text-2xl flowchart-arrow md:hidden">↓</div>
                            <div class="font-semibold">Execute Tx</div>
                        </div>
                    </div>
                    <div class="text-4xl flowchart-arrow">↓</div>
                    <div class="flowchart-step p-4 rounded-lg w-full md:w-1/2 text-center font-semibold">5. Monitor via Dashboard & Logs</div>
                </div>
            </section>

            <!-- Section 3: KPIs -->
            <section id="infographic-kpis" class="my-16 md:my-24 py-12 bg-white rounded-lg shadow-lg">
                 <h2 class="text-3xl md:text-4xl font-bold text-center mb-12" style="color: #0077B6;">Key Performance Indicators</h2>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-12 px-8">
                     <div>
                        <h3 class="text-2xl font-semibold text-center mb-4 text-gray-800">Action Distribution</h3>
                        <p class="text-center text-gray-600 mb-6">
                            This chart shows the typical probability of the script performing a 'Send' transaction versus choosing to remain 'Idle' for an action, a key feature for simulating non-robotic behavior.
                        </p>
                        <div class="chart-container">
                            <canvas id="infographicActionDistChart"></canvas>
                        </div>
                     </div>
                     <div>
                        <h3 class="text-2xl font-semibold text-center mb-4 text-gray-800">Sample Wallet Balances (ETH)</h3>
                         <p class="text-center text-gray-600 mb-6">
                            A snapshot of balances across multiple loaded wallets. The script provides real-time updates to this data as transactions are confirmed on the network.
                        </p>
                        <div class="chart-container">
                            <canvas id="infographicWalletBalanceChart"></canvas>
                        </div>
                     </div>
                 </div>
            </section>

            <!-- Section 4: Humanization Engine -->
            <section id="infographic-features" class="my-16 md:my-24">
                <h2 class="text-3xl md:text-4xl font-bold text-center mb-12" style="color: #0077B6;">The 'Humanization' Engine</h2>
                 <p class="text-lg text-center text-gray-600 max-w-3xl mx-auto mb-12">
                    To avoid being flagged as a bot, the script incorporates several layers of randomization. This engine ensures that the script's activity appears organic and unpredictable.
                </p>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-center">
                     <div class="bg-white p-6 rounded-lg shadow-lg">
                        <h3 class="text-2xl font-semibold text-center mb-4 text-gray-800">Randomized Gas Payments</h3>
                         <p class="text-center text-gray-600 mb-6">
                            Instead of using a fixed gas price, the script calculates a variable fee for each transaction, staying within a user-defined multiplier of the current network average to mimic human bidding behavior.
                        </p>
                        <div class="chart-container h-80">
                            <canvas id="infographicGasPriceChart"></canvas>
                        </div>
                     </div>
                     <div class="space-y-6">
                        <div class="kpi-card flex items-center space-x-4">
                            <span class="text-4xl">⏱️</span>
                            <div>
                                <h4 class="text-xl font-bold text-left" style="color: #0077B6;">Random Delays (Log-normal)</h4>
                                <p class="text-left text-gray-600">Waits for a random duration (e.g., 10-30 seconds) between actions, drawn from a log-normal distribution for more human-like timing.</p>
                            </div>
                        </div>
                        <div class="kpi-card flex items-center space-x-4">
                            <span class="text-4xl">💸</span>
                            <div>
                                <h4 class="text-xl font-bold text-left" style="color: #0077B6;">Random Amounts</h4>
                                <p class="text-left text-gray-600">Sends a variable amount of ETH within a specified range.</p>
                            </div>
                        </div>
                        <div class="kpi-card flex items-center space-x-4">
                            <span class="text-4xl">🔗</span>
                            <div>
                                <h4 class="text-xl font-bold text-left" style="color: #0077B6;">Random Chain & Wallet</h4>
                                <p class="text-left text-gray-600">Picks a random wallet and a random blockchain network for each session.</p>
                            </div>
                        </div>
                         <div class="kpi-card flex items-center space-x-4">
                            <span class="text-4xl">🎲</span>
                            <div>
                                <h4 class="text-xl font-bold text-left" style="color: #0077B6;">Per-Wallet Probability Jitter</h4>
                                <p class="text-left text-gray-600">Each wallet's action probabilities (send, idle, balance check) subtly vary from global settings.</p>
                            </div>
                        </div>
                         <div class="kpi-card flex items-center space-x-4">
                            <span class="text-4xl">⚙️</span>
                            <div>
                                <h4 class="text-xl font-bold text-left" style="color: #0077B6;">Simulated Errors & Retries</h4>
                                <p class="text-left text-gray-600">Introduces occasional simulated transaction failures, followed by exponential backoff retries.</p>
                            </div>
                        </div>
                     </div>
                </div>
            </section>

            <!-- Section 5: Recipient Strategy -->
            <section id="infographic-recipient-strategy" class="my-16 md:my-24 py-12 bg-white rounded-lg shadow-lg">
                <h2 class="text-3xl md:text-4xl font-bold text-center mb-12" style="color: #0077B6;">Recipient Strategy</h2>
                <p class="text-lg text-center text-gray-600 max-w-3xl mx-auto mb-12">
                    The script offers multiple modes for selecting transaction recipients, allowing for a wide range of interaction patterns.
                </p>
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 px-6">
                    <div class="kpi-card">
                        <span class="text-4xl">🔍</span>
                        <h4 class="text-lg font-bold my-2">Dynamic Pool</h4>
                        <p class="text-gray-600 text-sm">Scans recent blocks for active wallets (EOAs) and adds them to a recipient pool.</p>
                    </div>
                     <div class="kpi-card">
                        <span class="text-4xl">🎯</span>
                        <h4 class="text-lg font-bold my-2">Fixed Address</h4>
                        <p class="text-gray-600 text-sm">Sends all transactions to a single, predetermined address.</p>
                    </div>
                     <div class="kpi-card">
                        <span class="text-4xl">📝</span>
                        <h4 class="text-lg font-bold my-2">Custom List</h4>
                        <p class="text-gray-600 text-sm">Uses a user-provided list of addresses for transactions.</p>
                    </div>
                     <div class="kpi-card">
                        <span class="text-4xl">📄</span>
                        <h4 class="text-lg font-bold my-2">Predefined List</h4>
                        <p class="text-gray-600 text-sm">Loads recipients from an externally hosted or uploaded CSV file.</p>
                    </div>
                     <div class="kpi-card">
                        <span class="text-4xl">🤝</span>
                        <h4 class="text-lg font-bold my-2">Self-Interact</h4>
                        <p class="text-gray-600 text-sm">Loaded wallets send transactions to each other, creating an internal ecosystem.</p>
                    </div>
                     <div class="kpi-card bg-gray-100">
                        <span class="text-4xl">↪️</span>
                        <h4 class="text-lg font-bold my-2">Fallback Logic</h4>
                        <p class="text-gray-600 text-sm">If the Dynamic Pool is empty, it automatically falls back to Self-Interact mode.</p>
                    </div>
                </div>
            </section>


            <!-- Section 6: Security -->
            <section id="infographic-security" class="my-16 md:my-24">
                <div class="max-w-4xl mx-auto p-6 rounded-lg" style="background-color: #fffbe6; border: 1px solid #fde047;">
                    <div class="flex">
                        <div class="flex-shrink-0">
                             <span class="text-3xl">⚠️</span>
                        </div>
                        <div class="ml-4">
                            <h3 class="text-2xl font-bold" style="color: #ca8a04;">A Critical Security Notice</h3>
                            <div class="mt-2 text-md text-yellow-800">
                                <p>This is a client-side application. Handling private keys in a web browser is **extremely risky**. This tool is intended for educational and testing purposes **on test networks only**. Never input mainnet private keys or keys associated with wallets holding real assets. The developer assumes no responsibility for any loss of funds.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </div><!-- End infographic-content -->

    </main>

    <!-- NEW FOOTER SECTION -->
    <footer class="bg-secondary text-center text-accent py-8 mt-12 border-t border-accent">
        <div class="container mx-auto px-4 sm:px-6 lg:px-8">
            <h3 class="text-2xl font-bold text-main mb-2">We Grow Together!</h3>
            <p class="mb-4 max-w-2xl mx-auto">
                Consider supporting our development efforts by donating to the address below. Your contribution helps keep this project alive and continuously improving.
            </p>
            <div class="flex items-center justify-center bg-gray-100 p-3 rounded-lg max-w-md mx-auto mb-6">
                <span id="donation-address" class="text-sm md:text-base text-main font-mono break-all mr-2">0x1C46ccEA4D62d3eEC4DCE3501aa96d0Ff5FcA954</span>
                <button id="copy-address-btn" class="ml-auto p-2 rounded-md hover:bg-gray-200 transition-colors" title="Copy Address">
                    <svg id="copy-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16">
                        <path d="M4 1.5H3a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-8a1 1 0 0 1 1-1h1v-1z"/>
                        <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/>
                    </svg>
                     <svg id="check-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-check2 hidden text-green-500" viewBox="0 0 16 16">
                        <path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"/>
                    </svg>
                </button>
                <button id="show-qr-btn" class="ml-2 p-2 rounded-md hover:bg-gray-200 transition-colors" title="Show QR Code">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-qr-code" viewBox="0 0 16 16">
                        <path d="M2 2h2v2H2V2Z"/>
                        <path d="M6 0v6H0V0h6ZM5 1H1v4h4V1ZM4 12H2v2h2v-2Z"/>
                        <path d="M6 10v6H0v-6h6Zm-5 1v4h4v-4H1Zm11-9h2v2h-2V2Z"/>
                        <path d="M10 0v6h6V0h-6ZM5 1v4h-4V1h4ZM8 1V0h1v2H8v2H7V1h1Zm0 5V4h1v2H8ZM6 8V7h1V6h1v2h1V7h5v1h-4v1H7V8H6Zm0 0v1H2V8H1v1H0V7h3v1h3Zm10 1h-1V7h1v2Zm-1 0h-1v2h2v-1h-1V9Zm-4 0h2v1h-1v1h-1V9Zm2 3v-1h-1v1h-1v1H9v1h3v-2h1v-1h-3Zm-4-3v1h1v-2H7v1h2v1H7Z"/>
                        <path d="M7 12h1v3h4v1H7v-4Zm9 2v2h-3v-1h2v-1h1Z"/>
                    </svg>
                </button>
            </div>
            <p class="text-sm text-gray-500 mt-8 flex items-center justify-center">
                &copy; 2025 FarmLabs. All rights reserved.
                <a href="https://github.com/CryptoExplor/farmlabs" target="_blank" rel="noopener noreferrer" class="ml-4 text-gray-600 hover:text-blue-500">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38C13.71 14.53 16 11.54 16 8c0-4.42-3.58-8-8-8z"/>
                    </svg>
                </a>
            </p>
        </div>
    </footer>

    <!-- QR Code Modal -->
    <div id="qr-code-modal" class="modal hidden">
        <div class="modal-content text-main flex flex-col items-center text-center">
            <span class="close-qr-button self-end">&times;</span>
            <h3 class="text-xl font-bold mb-4">Donation Address</h3>
            <div id="qr-code-container" class="p-4 bg-white inline-block rounded-lg shadow-inner"></div>
            <p class="font-mono text-xs mt-4 break-all" id="qr-address-display"></p>
        </div>
    </div>
    
    <!-- Gemini Explanation Modal -->
    <div id="gemini-modal" class="modal hidden">
        <div class="modal-content text-main">
            <span class="close-button">&times;</span>
            <h3 id="modal-title" class="text-xl font-bold mb-4">Gemini Explanation</h3>
            <div id="modal-content" class="text-accent">
                <div class="modal-loader"></div>
                <p class="text-center mt-4">Generating explanation...</p>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmation-modal" class="modal hidden">
        <div class="modal-content text-main">
            <span class="close-confirm-button">&times;</span>
            <h3 class="text-xl font-bold mb-4">Confirm Action</h3>
            <p id="confirm-message" class="mb-6 text-accent">Are you sure you want to proceed?</p>
            <div class="flex justify-end space-x-4">
                <button id="cancel-confirm-btn" class="py-2 px-4 rounded-lg font-semibold btn-secondary">Cancel</button>
                <button id="confirm-action-btn" class="py-2 px-4 rounded-lg font-semibold btn-primary">Confirm</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const appState = {
                isRunning: false,
                stopFlag: false,
                wallets: [],
                rpcConfigs: [], // [{url, chainId}]
                currentRecipientPool: {}, // {chainId: [addresses]}
                manualRecipientList: [], // For user-provided list
                predefinedRecipientList: [], // Now loaded from CSV
                config: {},
                stats: {
                    totalActions: 0,
                    successfulActions: 0,
                    failedActions: 0,
                    // Updated actionCounts to include 'balance-check'
                    actionCounts: { send: 0, idle: 0, 'balance-check': 0, skipped: 0 }
                },
                logEntries: [], // For CSV export
                charts: {
                    walletBalance: null, // Console's wallet balance chart
                    actionDist: null,    // Console's action distribution chart
                    infographicActionDist: null, // Infographic's charts
                    infographicWalletBalance: null,
                    infographicGasPrice: null
                },
                pendingConfirmation: null, // Callback for confirmation modal
                connectedAddress: null,
            };


            const ui = {
                connectWalletBtn: document.getElementById('connect-wallet-btn'),
                walletStatusDisplay: document.getElementById('wallet-status-display'),
                walletFeatureControls: document.querySelectorAll('.wallet-feature-control'),
                startBtn: document.getElementById('start-btn'),
                stopBtn: document.getElementById('stop-btn'),
                clearAllDataBtn: document.getElementById('clear-all-data-btn'),
                maxTxnsPerWallet: document.getElementById('max-txns-per-wallet'),
                walletIdleChance: document.getElementById('wallet-idle-chance'),
                minAmount: document.getElementById('min-amount'),
                maxAmount: document.getElementById('max-amount'),
                minDelay: document.getElementById('min-delay'),
                maxDelay: document.getElementById('max-delay'),
                gasMultiplier: document.getElementById('gas-multiplier'),
                minGasFactor: document.getElementById('min-gas-factor'),
                maxGasFactor: document.getElementById('max-gas-factor'),
                blockLookback: document.getElementById('block-lookback'),
                probJitterFactor: document.getElementById('prob-jitter-factor'), // NEW
                simulatedErrorChance: document.getElementById('simulated-error-chance'), // NEW
                rpcUrls: document.getElementById('rpc-urls'),
                testRpcBtn: document.getElementById('test-rpc-btn'),
                probSend: document.getElementById('prob-send'),
                probIdleAction: document.getElementById('prob-idle-action'),
                probBalanceCheck: document.getElementById('prob-balance-check'), // NEW
                probSumWarning: document.getElementById('prob-sum-warning'),
                privateKeys: document.getElementById('private-keys'),
                loadKeysBtn: document.getElementById('load-keys-btn'),
                keysLoadedCount: document.getElementById('keys-loaded-count'),
                walletListDisplay: document.getElementById('wallet-list-display'),
                noWalletsMsg: document.getElementById('no-wallets-msg'),
                recipientMode: document.getElementsByName('recipient-mode'),
                fixedAddressSection: document.getElementById('fixed-address-section'),
                fixedAddress: document.getElementById('fixed-address'),
                listAddressesSection: document.getElementById('list-addresses-section'),
                listAddresses: document.getElementById('list-addresses'),
                loadAddressesFromListBtn: document.getElementById('load-addresses-from-list-btn'),
                listAddressesCount: document.getElementById('list-addresses-count'),
                predefinedAddressesSection: document.getElementById('predefined-addresses-section'),
                predefinedFileInput: document.getElementById('predefined-file-input'),
                loadPredefinedFileBtn: document.getElementById('load-predefined-file-btn'),
                predefinedAddressesInfo: document.getElementById('predefined-addresses-info'),
                predefinedAddressesDisplay: document.getElementById('predefined-addresses-display'),
                predefinedAddressesCount: document.getElementById('predefined-addresses-count'),
                liveLog: document.getElementById('live-log'),
                downloadLogBtn: document.getElementById('download-log-btn'),
                progressBar: document.getElementById('progress-bar'),
                progressText: document.getElementById('progress-text'),
                statusDisplay: document.getElementById('status-display'),
                successCount: document.getElementById('success-count'),
                failCount: document.getElementById('fail-count'),
                gasDisplay: document.getElementById('gas-display'),
                walletBalanceChartCanvas: document.getElementById('wallet-balance-chart'),
                actionDistChartCanvas: document.getElementById('action-dist-chart'),
                explainSendTxBtn: document.getElementById('explain-send-tx-btn'),
                geminiModal: document.getElementById('gemini-modal'),
                modalTitle: document.getElementById('modal-title'),
                modalContent: document.getElementById('modal-content'),
                closeModalBtn: document.querySelector('#gemini-modal .close-button'),
                confirmationModal: document.getElementById('confirmation-modal'),
                confirmMessage: document.getElementById('confirm-message'),
                confirmActionBtn: document.getElementById('confirm-action-btn'),
                cancelConfirmBtn: document.getElementById('cancel-confirm-btn'),
                closeConfirmBtn: document.querySelector('#confirmation-modal .close-confirm-button'),

                // New UI elements for page switching
                scriptConsoleContent: document.getElementById('script-console-content'),
                infographicContent: document.getElementById('infographic-content'),
                navLinks: document.querySelectorAll('.nav-link'),

                // Infographic chart canvases
                infographicActionDistChartCanvas: document.getElementById('infographicActionDistChart'),
                infographicWalletBalanceChartCanvas: document.getElementById('infographicWalletBalanceChart'),
                infographicGasPriceChartCanvas: document.getElementById('infographicGasPriceChart'),
            };

            // Function to enable/disable UI elements
            const setUIEnabled = (enabled) => {
                ui.walletFeatureControls.forEach(control => {
                    control.disabled = !enabled;
                    // Adjust opacity/cursor for radio buttons based on enabled state
                    if (control.type === 'radio') {
                         control.parentElement.style.opacity = enabled ? '1' : '0.6';
                         control.parentElement.style.cursor = enabled ? 'default' : 'not-allowed';
                    }
                });

                // Correctly show/hide recipient sections based on selected mode
                const selectedRecipientMode = Array.from(ui.recipientMode).find(r => r.checked)?.value;
                if (enabled) {
                    ui.fixedAddressSection.classList.toggle('hidden', selectedRecipientMode !== 'fixed');
                    ui.listAddressesSection.classList.toggle('hidden', selectedRecipientMode !== 'list');
                    ui.predefinedAddressesSection.classList.toggle('hidden', selectedRecipientMode !== 'predefined');
                } else {
                    // When disabled, hide all recipient specific sections
                    ui.fixedAddressSection.classList.add('hidden');
                    ui.listAddressesSection.classList.add('hidden');
                    ui.predefinedAddressesSection.classList.add('hidden');
                }

                // Reset specific elements when disabled
                if (!enabled) {
                    ui.privateKeys.value = '';
                    ui.keysLoadedCount.textContent = '';
                    appState.wallets = [];
                    updateWalletBalanceChart(); // Update console's chart
                    ui.rpcUrls.value = `https://mainnet.infura.io/v3/YOUR_PROJECT_ID,1\nhttps://rpc.goerli.dev,5`;
                    // Reset action probabilities to default
                    ui.probSend.value = "60"; // New default
                    ui.probIdleAction.value = "20"; // New default
                    ui.probBalanceCheck.value = "20"; // New default
                }
            };

            const openGeminiModal = (title, contentHtml) => {
                ui.modalTitle.textContent = title;
                ui.modalContent.innerHTML = contentHtml;
                ui.geminiModal.classList.remove('hidden');
            };

            const closeGeminiModal = () => {
                ui.geminiModal.classList.add('hidden');
                ui.modalContent.innerHTML = '<div class="modal-loader"></div><p class="text-center mt-4">Generating explanation...</p>';
            };

            const openConfirmationModal = (message, callback) => {
                ui.confirmMessage.textContent = message;
                appState.pendingConfirmation = callback;
                ui.confirmationModal.classList.remove('hidden');
            };

            const closeConfirmationModal = () => {
                ui.confirmationModal.classList.add('hidden');
                appState.pendingConfirmation = null;
            };

            const confirmAction = () => {
                if (appState.pendingConfirmation) {
                    appState.pendingConfirmation(true);
                }
                closeConfirmationModal();
            };

            const cancelAction = () => {
                if (appState.pendingConfirmation) {
                    appState.pendingConfirmation(false);
                }
                closeConfirmationModal();
            };

            const log = (message, type = 'info', actionData = {}) => {
                const timestamp = new Date().toLocaleTimeString();
                const logEntryDiv = document.createElement('div');
                logEntryDiv.innerHTML = `<span class="text-gray-500 mr-2">${timestamp}</span> <span class="log-${type}">${message}</span>`;
                ui.liveLog.appendChild(logEntryDiv);
                ui.liveLog.scrollTop = ui.liveLog.scrollHeight;

                appState.logEntries.push({
                    Timestamp: new Date().toISOString(),
                    ChainID: actionData.chainId || '',
                    WalletAddress: actionData.walletAddress || '',
                    Action: actionData.action || 'Log',
                    Status: type.toUpperCase(),
                    Details: message.replace(/<[^>]*>?/gm, '').replace(/,/g, ';')
                });
            };

            // Global utility functions for chart labels and tooltips
            const wrapLabel = (str, maxLen = 16) => {
                if (str.length <= maxLen) {
                    return str;
                }
                const words = str.split(' ');
                const lines = [];
                let currentLine = '';
                for (const word of words) {
                    if ((currentLine + ' ' + word).length > maxLen && currentLine.length > 0) {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine += (currentLine.length === 0 ? '' : ' ') + word;
                    }
                }
                if (currentLine.length > 0) {
                    lines.push(currentLine);
                }
                return lines;
            };

            const mandatoryTooltipConfig = {
                plugins: {
                    tooltip: {
                        callbacks: {
                            title: function(tooltipItems) {
                                const item = tooltipItems[0];
                                if (!item) return '';
                                let label = item.chart.data.labels[item.dataIndex];
                                return Array.isArray(label) ? label.join(' ') : label;
                            }
                        }
                    }
                }
            };

            const initConsoleCharts = () => {
                const chartOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#2d3748' } } },
                    scales: {
                        x: { ticks: { color: '#4a5568' } },
                        y: { ticks: { color: '#4a5568' } }
                    }
                };

                appState.charts.walletBalance = new Chart(ui.walletBalanceChartCanvas, {
                    type: 'bar',
                    data: { labels: [], datasets: [{ label: 'ETH Balance', data: [], backgroundColor: '#60a5fa', borderColor: '#3b82f6', borderWidth: 1 }] },
                    options: { ...chartOptions, indexAxis: 'y' }
                });

                appState.charts.actionDist = new Chart(ui.actionDistChartCanvas, {
                    type: 'doughnut',
                    data: {
                        // Updated labels for new action types
                        labels: ['Send', 'Idle', 'Balance Check', 'Skipped'],
                        datasets: [{
                            label: 'Actions',
                            // Updated data array size for 4 categories
                            data: [0, 0, 0, 0],
                            // Updated colors for consistency and new action type
                            backgroundColor: ['#3b82f6', '#a8a29e', '#f59e0b', '#ef4444'],
                            borderColor: '#ffffff',
                            borderWidth: 1
                        }]
                    },
                    options: { ...chartOptions, scales: {} }
                });
            };

            const updateWalletBalanceChart = () => {
                const chart = appState.charts.walletBalance;
                chart.data.labels = appState.wallets.map(w => `...${w.address.slice(-6)}`);
                chart.data.datasets[0].data = appState.wallets.map(w => w.balance);
                chart.update();

                if (appState.wallets.length > 0) {
                    ui.noWalletsMsg.classList.add('hidden');
                    ui.walletListDisplay.innerHTML = appState.wallets.map(w =>
                        `<li>Wallet: ...${w.address.slice(-10)} | Balance: ${w.balance} ETH</li>`
                    ).join('');
                } else {
                    ui.noWalletsMsg.classList.remove('hidden');
                    ui.walletListDisplay.innerHTML = '<li id="no-wallets-msg">No wallets loaded yet.</li>';
                }
            };

            const updateActionDistChart = (actionType) => {
                appState.stats.actionCounts[actionType]++;
                const chart = appState.charts.actionDist;
                // Update dataMap for new labels
                const dataMap = {
                    send: 0, idle: 1, 'balance-check': 2, skipped: 3
                };
                if (dataMap[actionType] !== undefined) {
                    chart.data.datasets[0].data[dataMap[actionType]] = appState.stats.actionCounts[actionType];
                    chart.update();
                }
            };

            // Infographic Chart Initialization Functions
            const initInfographicActionDistChart = () => {
                const ctx = ui.infographicActionDistChartCanvas?.getContext('2d');
                if (!ctx) return;
                // Destroy existing chart if it exists to prevent re-initialization errors
                if (appState.charts.infographicActionDist) {
                    appState.charts.infographicActionDist.destroy();
                }
                appState.charts.infographicActionDist = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        // Updated labels to reflect new action type in infographic
                        labels: ['Send Transaction', 'Idle (No Action)', 'Balance Check'],
                        datasets: [{
                            label: 'Action Probability',
                            // Updated data to match new default probabilities
                            data: [60, 20, 20],
                            backgroundColor: ['#00B4D8', '#90E0EF', '#fcd34d'], // Added color for balance check
                            borderColor: '#ffffff',
                            borderWidth: 2,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                             ...mandatoryTooltipConfig.plugins,
                            legend: {
                                position: 'top',
                                labels: {
                                    color: '#212529' // Infographic text color
                                }
                            },
                        }
                    }
                });
            };
            
            const initInfographicWalletBalanceChart = () => {
                const ctx = ui.infographicWalletBalanceChartCanvas?.getContext('2d');
                if (!ctx) return;
                // Destroy existing chart if it exists to prevent re-initialization errors
                if (appState.charts.infographicWalletBalance) {
                    appState.charts.infographicWalletBalance.destroy();
                }
                const walletLabels = ['Wallet ...a4b8', 'Wallet ...f9c1', 'Wallet ...3d2e', 'Wallet ...e6a7', 'Wallet ...b8d9'];

                appState.charts.infographicWalletBalance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: walletLabels.map(label => wrapLabel(label)),
                        datasets: [{
                            label: 'Balance (ETH)',
                            data: [1.2, 0.8, 2.5, 0.5, 1.9],
                            backgroundColor: '#00B4D8',
                            borderColor: '#0077B6',
                            borderWidth: 1,
                            borderRadius: 5,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                         ...mandatoryTooltipConfig,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    color: '#4a5568' // Infographic text accent
                                }
                            },
                            x: {
                                ticks: {
                                    color: '#4a5568' // Infographic text accent
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#212529'
                                }
                            }
                        }
                    }
                });
            };
            
            const initInfographicGasPriceChart = () => {
                const ctx = ui.infographicGasPriceChartCanvas?.getContext('2d');
                if (!ctx) return;
                // Destroy existing chart if it exists to prevent re-initialization errors
                if (appState.charts.infographicGasPrice) {
                    appState.charts.infographicGasPrice.destroy();
                }

                const labels = ['T-10', 'T-9', 'T-8', 'T-7', 'T-6', 'T-5', 'T-4', 'T-3', 'T-2', 'T-1'];
                const networkBaseFee = Array(10).fill(20);
                const randomGasPrice = Array.from({length: 10}, () => Math.random() * 30 + 20);

                appState.charts.infographicGasPrice = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Network Base Fee (Gwei)',
                                data: networkBaseFee,
                                borderColor: '#90E0EF',
                                borderWidth: 2,
                                tension: 0.1,
                                pointRadius: 0,
                            },
                            {
                                label: 'Script\'s Randomized Gas (Gwei)',
                                data: randomGasPrice,
                                borderColor: '#0077B6',
                                backgroundColor: 'rgba(0, 119, 182, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        ...mandatoryTooltipConfig,
                        scales: {
                            y: {
                                beginAtZero: false,
                                ticks: {
                                    callback: function(value) {
                                        return value + ' Gwei'
                                    },
                                    color: '#4a5568' // Infographic text accent
                                }
                            },
                            x: {
                                ticks: {
                                    color: '#4a5568' // Infographic text accent
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#212529'
                                }
                            }
                        }
                    }
                });
            };


            const loadConfiguration = () => {
                const probInputs = document.querySelectorAll('.prob-input');
                let totalProb = 0;
                probInputs.forEach(input => totalProb += parseInt(input.value) || 0);

                if (totalProb !== 100) {
                    ui.probSumWarning.classList.remove('hidden');
                    return false;
                } else {
                    ui.probSumWarning.classList.add('hidden');
                }

                const minAmount = parseFloat(ui.minAmount.value);
                const maxAmount = parseFloat(ui.maxAmount.value);
                if (minAmount > maxAmount) {
                    log('Error: Minimum amount cannot be greater than maximum amount.', 'error');
                    return false;
                }

                const minDelay = parseInt(ui.minDelay.value);
                const maxDelay = parseInt(ui.maxDelay.value);
                if (minDelay > maxDelay) {
                    log('Error: Minimum delay cannot be greater than maximum delay.', 'error');
                    return false;
                }

                const minGasFactor = parseFloat(ui.minGasFactor.value);
                const maxGasFactor = parseFloat(ui.maxGasFactor.value);
                if (minGasFactor > maxGasFactor || minGasFactor <= 0) {
                    log('Error: Minimum gas factor must be greater than 0 and less than or equal to maximum gas factor.', 'error');
                    return false;
                }

                appState.config = {
                    maxTxnsPerWallet: parseInt(ui.maxTxnsPerWallet.value) || 3,
                    walletIdleChance: parseInt(ui.walletIdleChance.value) || 25,
                    minAmount: minAmount || 0.0001,
                    maxAmount: maxAmount || 0.0002,
                    minDelay: minDelay * 1000 || 10000,
                    maxDelay: maxDelay * 1000 || 30000,
                    gasMultiplier: parseFloat(ui.gasMultiplier.value) || 2,
                    minGasFactor: minGasFactor || 0.9,
                    maxGasFactor: maxGasFactor || 1.1,
                    blockLookback: parseInt(ui.blockLookback.value) || 100,
                    probJitterFactor: parseInt(ui.probJitterFactor.value) || 5, // NEW config
                    simulatedErrorChance: parseInt(ui.simulatedErrorChance.value) || 0, // NEW config
                    recipientMode: Array.from(ui.recipientMode).find(r => r.checked).value,
                    fixedAddress: ui.fixedAddress.value.trim(),
                    probabilities: {
                        send: parseInt(ui.probSend.value) || 60, // Updated default
                        idle: parseInt(ui.probIdleAction.value) || 20, // Updated default
                        'balance-check': parseInt(ui.probBalanceCheck.value) || 20, // NEW default
                    }
                };

                appState.rpcConfigs = ui.rpcUrls.value.split('\n').map(line => {
                    const [url, chainIdStr] = line.split(',').map(s => s.trim());
                    const chainId = parseInt(chainIdStr);
                    if (!url || isNaN(chainId)) {
                        log(`Warning: Invalid RPC entry ignored: "${line}". Format should be "URL,ChainID".`, 'warning');
                        return null;
                    }
                    return { url, chainId: chainId };
                }).filter(Boolean);

                return true;
            };

            const getRandomInRange = (min, max) => Math.random() * (max - min) + min;

            // Log-normal random number generator for human-like delays [41]
            let spareRandom = null;
            function normalRandom() {
                let val, u, v, s, mul;
                if(spareRandom !== null) {
                    val = spareRandom;
                    spareRandom = null;
                } else {
                    do {
                        u = Math.random() * 2 - 1;
                        v = Math.random() * 2 - 1;
                        s = u * u + v * v;
                    } while(s === 0 || s >= 1);
                    mul = Math.sqrt(-2 * Math.log(s) / s);
                    val = u * mul;
                    spareRandom = v * mul;
                }
                return val;
            }

            // Function to generate a log-normal random number scaled to a desired mean and stddev
            // Here, gmean is the geometric mean (or a target center), gstddev is the geometric standard deviation.
            // For delays, we want values mostly between minDelay and maxDelay.
            // A simple approach is to use a distribution that has its values within these bounds.
            // For more control, min and max can act as hard clamps.
            function lnRandomScaled(min, max) {
                // Approximate geometric mean and stddev for the log-normal distribution
                // This is a simplification; for precise control over min/max,
                // you'd need to solve for mu and sigma given desired percentiles.
                const logMin = Math.log(min);
                const logMax = Math.log(max);
                const mu = (logMin + logMax) / 2;
                // A fixed standard deviation for the underlying normal distribution.
                // Adjust this value to change the "spread" of the log-normal distribution.
                // A higher sigma means more values further from the mean.
                // Using a value that generally keeps outputs within a reasonable range.
                const sigma = (logMax - logMin) / 4; // Arbitrary scaling factor to fit within range

                let randomLogValue = normalRandom() * sigma + mu;
                let result = Math.exp(randomLogValue);

                // Clamp the result to be within the specified min and max
                return Math.max(min, Math.min(max, result));
            }


            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            // Modified chooseAction to use per-wallet probabilities
            const chooseAction = (walletSessionProbs) => {
                const rand = Math.random() * 100;
                let cumulativeProb = 0;

                if (rand < (cumulativeProb += walletSessionProbs.send)) return 'send';
                if (rand < (cumulativeProb += walletSessionProbs.idle)) return 'idle-action';
                if (rand < (cumulativeProb += walletSessionProbs['balance-check'])) return 'balance-check';
                return 'idle-action'; // Fallback, should not be reached if sum is 100
            };

            const scanRecentBlocks = async (rpc, chainId) => {
                appState.currentRecipientPool[chainId] = appState.currentRecipientPool[chainId] || [];
                const provider = new ethers.JsonRpcProvider(rpc);
                log(`Scanning ${appState.config.blockLookback} blocks on Chain ID ${chainId}...`, 'info');
                try {
                    const currentBlockNumber = await provider.getBlockNumber();
                    const startBlock = Math.max(0, currentBlockNumber - appState.config.blockLookback);
                    const newAddresses = new Set();

                    for (let blk = startBlock; blk <= currentBlockNumber; blk++) {
                        const block = await provider.getBlock(blk, true);
                        if (block && block.transactions) {
                            block.transactions.forEach(tx => {
                                if (tx.to && ethers.isAddress(tx.to)) {
                                    newAddresses.add(tx.to);
                                }
                            });
                        }
                    }

                    const existingAddresses = new Set(appState.currentRecipientPool[chainId]);
                    newAddresses.forEach(addr => existingAddresses.add(addr));
                    appState.currentRecipientPool[chainId] = Array.from(existingAddresses);
                    log(`Found ${newAddresses.size} new addresses. Total recipients for chain ${chainId}: ${appState.currentRecipientPool[chainId].length}`, 'success');
                } catch (error) {
                    log(`Failed to scan blocks for chain ${chainId}: ${error.message}`, 'error');
                }
            };

            async function callGeminiApi(prompt) {
                log('Calling Gemini API for explanation...', 'info');
                openGeminiModal('Getting Explanation...', '<div class="modal-loader"></div><p class="text-center mt-4">Generating explanation...</p>');
                const apiKey = ""; // API key is left blank, Canvas will provide it at runtime.
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }]
                };

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const result = await response.json();
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const explanation = result.candidates[0].content.parts[0].text;
                        ui.modalTitle.textContent = "Gemini Explanation";
                        ui.modalContent.innerHTML = `<p>${explanation.replace(/\n/g, '<br>')}</p>`;
                        return explanation;
                    } else {
                        ui.modalTitle.textContent = "Gemini Explanation Error";
                        ui.modalContent.innerHTML = `<p class="text-red-500">No explanation generated. The model might have been unable to process the request or returned an unexpected format.</p>`;
                        return "No explanation generated.";
                    }
                } catch (error) {
                    console.error("Gemini API call failed:", error);
                    ui.modalTitle.textContent = "Gemini API Error";
                    ui.modalContent.innerHTML = `<p class="text-red-500">Failed to get explanation: ${error.message}. Please check your network connection or try again later.</p>`;
                    return `Failed to get explanation: ${error.message}.`;
                }
            }


            const loadWallets = async () => {
                const keys = ui.privateKeys.value.split('\n').map(k => k.trim()).filter(Boolean);
                if (keys.length === 0) {
                    log('No private keys provided.', 'error');
                    return;
                }
                if (appState.rpcConfigs.length === 0) {
                    log('Please provide at least one RPC URL and Chain ID in Configuration.', 'error');
                    return;
                }

                log(`Attempting to load ${keys.length} wallets and check balances...`, 'info');
                appState.wallets = [];
                ui.keysLoadedCount.textContent = `Loading 0 / ${keys.length}...`;

                const defaultProvider = new ethers.JsonRpcProvider(appState.rpcConfigs[0].url);
                const baseProbabilities = appState.config.probabilities;
                const jitterFactor = appState.config.probJitterFactor / 100; // Convert % to decimal

                for (let i = 0; i < keys.length; i++) {
                    try {
                        const wallet = new ethers.Wallet(keys[i], defaultProvider);
                        const balanceWei = await defaultProvider.getBalance(wallet.address);
                        const balanceEth = ethers.formatEther(balanceWei);

                        // Calculate per-wallet probabilities with jitter
                        let sendJitter = getRandomInRange(-jitterFactor, jitterFactor) * baseProbabilities.send;
                        let idleJitter = getRandomInRange(-jitterFactor, jitterFactor) * baseProbabilities.idle;
                        let balanceCheckJitter = getRandomInRange(-jitterFactor, jitterFactor) * baseProbabilities['balance-check'];

                        let currentSend = Math.max(0, baseProbabilities.send + sendJitter);
                        let currentIdle = Math.max(0, baseProbabilities.idle + idleJitter);
                        let currentBalanceCheck = Math.max(0, baseProbabilities['balance-check'] + balanceCheckJitter);

                        // Normalize probabilities to sum to 100
                        const sum = currentSend + currentIdle + currentBalanceCheck;
                        const walletSessionProbs = {
                            send: (currentSend / sum) * 100,
                            idle: (currentIdle / sum) * 100,
                            'balance-check': (currentBalanceCheck / sum) * 100
                        };

                        appState.wallets.push({
                            privateKey: keys[i],
                            address: wallet.address,
                            balance: parseFloat(balanceEth).toFixed(6),
                            sessionProbabilities: walletSessionProbs // Store per-wallet probabilities
                        });
                        ui.keysLoadedCount.textContent = `Loaded ${i + 1} / ${keys.length} wallets.`;
                    } catch (error) {
                        log(`Failed to load key #${i+1}: Invalid key or RPC issue - ${error.message}`, 'error');
                    }
                }

                log(`Successfully loaded ${appState.wallets.length} wallets and their balances.`, 'success');
                ui.keysLoadedCount.textContent = `Loaded ${appState.wallets.length} wallets.`;
                updateWalletBalanceChart();
            };

            const testRpcConnections = async () => {
                loadConfiguration();
                if (appState.rpcConfigs.length === 0) {
                    log('No RPC URLs configured to test.', 'warning');
                    return;
                }

                log('Testing RPC connections...', 'info');
                for (const rpcConfig of appState.rpcConfigs) {
                    const provider = new ethers.JsonRpcProvider(rpcConfig.url);
                    try {
                        const network = await provider.getNetwork();
                        const blockNumber = await provider.getBlockNumber();
                        if (network.chainId === BigInt(rpcConfig.chainId)) {
                            log(`✅ RPC ${rpcConfig.url} connected (Chain ID: ${network.chainId}, Latest Block: ${blockNumber})`, 'success');
                        } else {
                            log(`⚠️ RPC ${rpcConfig.url} connected but Chain ID mismatch. Configured: ${rpcConfig.chainId}, Actual: ${network.chainId}. Latest Block: ${blockNumber}.`, 'warning');
                        }
                    }
                    catch (error) {
                        log(`❌ Failed to connect to RPC ${rpcConfig.url}: ${error.message}`, 'error');
                    }
                }
                log('RPC connection testing complete.', 'info');
            };

            const loadAddressesFromList = () => {
                const addressesInput = ui.listAddresses.value.split('\n').map(addr => addr.trim()).filter(Boolean);
                const validAddresses = [];
                let invalidCount = 0;

                addressesInput.forEach(addr => {
                    if (ethers.isAddress(addr)) {
                        validAddresses.push(addr);
                    } else {
                        invalidCount++;
                        log(`Invalid address in list: "${addr}"`, 'warning');
                    }
                });

                appState.manualRecipientList = validAddresses;
                ui.listAddressesCount.textContent = `Loaded ${validAddresses.length} valid addresses. ${invalidCount > 0 ? `(${invalidCount} invalid ignored)` : ''}`;
                if (validAddresses.length > 0) {
                    log(`Successfully loaded ${validAddresses.length} recipient addresses from list.`, 'success');
                } else {
                    log('No valid addresses loaded from list.', 'warning');
                }
            };

            const loadPredefinedListFromFile = () => {
                const file = ui.predefinedFileInput.files[0];
                if (!file) {
                    log('No file selected for predefined list.', 'warning');
                    ui.predefinedAddressesInfo.textContent = 'No file loaded.';
                    ui.predefinedAddressesCount.textContent = '';
                    appState.predefinedRecipientList = [];
                    updatePredefinedAddressesDisplay();
                    return;
                }

                ui.predefinedAddressesInfo.textContent = `Loading file: ${file.name}...`;
                log(`Attempting to load predefined addresses from ${file.name}...`, 'info');

                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    const addresses = content.split(/\r?\n/).map(line => line.trim()).filter(Boolean);
                    const validAddresses = [];
                    let invalidCount = 0;

                    addresses.forEach(addr => {
                        if (ethers.isAddress(addr)) {
                            validAddresses.push(addr);
                        } else {
                            invalidCount++;
                            log(`Invalid address in predefined file: "${addr}"`, 'warning');
                        }
                    });

                    appState.predefinedRecipientList = validAddresses;
                    ui.predefinedAddressesInfo.textContent = `File loaded: ${file.name}`;
                    ui.predefinedAddressesCount.textContent = `List contains ${validAddresses.length} valid addresses. ${invalidCount > 0 ? `(${invalidCount} invalid ignored)` : ''}`;
                    if (validAddresses.length > 0) {
                        log(`Successfully loaded ${validAddresses.length} addresses from "${file.name}".`, 'success');
                    } else {
                        log(`No valid addresses found in "${file.name}".`, 'warning');
                    }
                    updatePredefinedAddressesDisplay();
                };

                reader.onerror = (e) => {
                    log(`Error reading file: ${e.target.error.name}`, 'error');
                    ui.predefinedAddressesInfo.textContent = 'Error loading file.';
                    ui.predefinedAddressesCount.textContent = '';
                    appState.predefinedRecipientList = [];
                    updatePredefinedAddressesDisplay();
                };

                reader.readAsText(file);
            };

            const updatePredefinedAddressesDisplay = () => {
                ui.predefinedAddressesDisplay.innerHTML = '';
                if (appState.predefinedRecipientList.length > 0) {
                    appState.predefinedRecipientList.forEach(addr => {
                        const li = document.createElement('li');
                        li.textContent = addr;
                        ui.predefinedAddressesDisplay.appendChild(li);
                    });
                } else {
                    ui.predefinedAddressesDisplay.innerHTML = '<li>No predefined addresses loaded.</li>';
                }
            };


            const startFarming = async () => {
                openConfirmationModal('Are you sure you want to start transaction farming? Ensure your settings and keys are for test purposes only, as this involves real blockchain interactions.', async (confirmed) => {
                    if (!confirmed) {
                        log('Farming start cancelled by user.', 'info');
                        return;
                    }

                    if (!loadConfiguration()) {
                        log('Configuration is invalid. Please fix errors before starting.', 'error');
                        return;
                    }

                    if (appState.wallets.length === 0) {
                        log('Please load wallets first.', 'error');
                        return;
                    }
                    if (appState.rpcConfigs.length === 0) {
                        log('Please provide at least one RPC URL and Chain ID.', 'error');
                        return;
                    }
                    if (appState.config.recipientMode === 'fixed' && !ethers.isAddress(appState.config.fixedAddress)) {
                        log('Invalid fixed recipient address.', 'error');
                        return;
                    }
                    if (appState.config.recipientMode === 'list' && appState.manualRecipientList.length === 0) {
                        log('Recipient list is empty. Please load addresses into the list or choose another recipient mode.', 'error');
                        return;
                    }
                    if (appState.config.recipientMode === 'predefined' && appState.predefinedRecipientList.length === 0) {
                        log('Predefined recipient list is empty. Please load a CSV file with addresses.', 'error');
                        return;
                    }
                    if (appState.config.recipientMode === 'self-interact' && appState.wallets.length < 2) {
                        log('To use "interact with each other" mode, you need at least 2 loaded wallets.', 'error');
                        return;
                    }
                    
                    appState.isRunning = true;
                    appState.stopFlag = false;
                    // Reset action counts for all action types
                    appState.stats = { totalActions: 0, successfulActions: 0, failedActions: 0, actionCounts: { send: 0, idle: 0, 'balance-check': 0, skipped: 0 } };
                    appState.logEntries = [];
                    // Update chart with new labels and reset data
                    appState.charts.actionDist.data.labels = ['Send', 'Idle', 'Balance Check', 'Skipped'];
                    appState.charts.actionDist.data.datasets[0].data = [0, 0, 0, 0];
                    appState.charts.actionDist.update();


                    ui.startBtn.disabled = true;
                    ui.stopBtn.disabled = false;
                    ui.statusDisplay.textContent = 'Running';
                    ui.successCount.textContent = appState.stats.successfulActions.toString();
                    ui.failCount.textContent = appState.stats.failedActions.toString();
                    ui.progressText.textContent = '0';
                    ui.progressBar.style.width = `100%`;


                    log(`Starting transaction farming process across ${appState.rpcConfigs.length} chains and ${appState.wallets.length} wallets.`, 'info');

                    // Pre-scan all RPCs for addresses for the 'pool' mode
                    if (appState.config.recipientMode === 'pool') {
                        log('Pre-scanning all configured chains for recipient addresses for the dynamic pool...', 'info');
                        for (const rpcConfig of appState.rpcConfigs) {
                            await scanRecentBlocks(rpcConfig.url, rpcConfig.chainId);
                        }
                        log('Pre-scanning complete.', 'info');
                    }

                    // Main farming loop: continuously runs until stop button is clicked
                    while (appState.isRunning && !appState.stopFlag) {
                        // Randomly select an RPC configuration for this session
                        const rpcConfigIndex = Math.floor(Math.random() * appState.rpcConfigs.length);
                        const rpcConfig = appState.rpcConfigs[rpcConfigIndex];
                        const rpcUrl = rpcConfig.url;
                        const chainId = rpcConfig.chainId;
                        const provider = new ethers.JsonRpcProvider(rpcUrl);

                        // Randomly select a wallet for this session
                        const walletInfoIndex = Math.floor(Math.random() * appState.wallets.length);
                        const walletInfo = appState.wallets[walletInfoIndex];
                        const walletAddress = walletInfo.address;
                        let wallet = new ethers.Wallet(walletInfo.privateKey, provider);

                        log(`🌐 Initiating session for Wallet ...${walletAddress.slice(-6)} on Chain ID ${chainId} (${rpcUrl})...`, 'info');

                        // Check for idle chance for the wallet session
                        if (Math.random() * 100 < appState.config.walletIdleChance) {
                            log(`Wallet ...${walletAddress.slice(-6)} is idle this session on Chain ID ${chainId}.`, 'info', { chainId, walletAddress, action: 'idle' });
                            updateActionDistChart('idle');
                            const delay = lnRandomScaled(appState.config.minDelay, appState.config.maxDelay);
                            await sleep(delay);
                            continue; // Move to next wallet/chain session
                        }

                        // Balance check for the current wallet on the current chain
                        try {
                            const balanceWei = await provider.getBalance(walletAddress);
                            if (balanceWei < ethers.parseEther("0.001")) { // Ensure sufficient balance for gas
                                log(`Skipping wallet ...${walletAddress.slice(-6)} on Chain ID ${chainId} due to critically low balance (${ethers.formatEther(balanceWei)} ETH).`, 'warning', { chainId, walletAddress, action: 'skipped' });
                                updateActionDistChart('skipped');
                                const delay = lnRandomScaled(appState.config.minDelay, appState.config.maxDelay);
                                await sleep(delay); // Add delay even for skipped
                                continue; // Move to next wallet/chain session
                            } else if (balanceWei < ethers.parseEther("0.005")) { // Warning for slightly low balance
                                 log(`Wallet ...${walletAddress.slice(-6)} on Chain ID ${chainId} has low balance (${ethers.formatEther(balanceWei)} ETH).`, 'warning', { chainId, walletAddress, action: 'info' });
                            }
                        } catch (balanceError) {
                            log(`Failed to check balance for ...${walletAddress.slice(-6)} on Chain ID ${chainId}: ${balanceError.message}`, 'error', { chainId, walletAddress, action: 'skipped' });
                            updateActionDistChart('skipped');
                            const delay = lnRandomScaled(appState.config.minDelay, appState.config.maxDelay);
                            await sleep(delay);
                            continue; // Move to next wallet/chain session
                        }

                        // Variable session length: random number of actions between 1 and maxTxnsPerWallet
                        const actionsForWallet = Math.floor(getRandomInRange(1, appState.config.maxTxnsPerWallet + 1));
                        log(`Wallet ...${walletAddress.slice(-6)} will perform ${actionsForWallet} action(s) on Chain ID ${chainId}.`, 'info');

                        for (let i = 1; i <= actionsForWallet; i++) {
                            if (appState.stopFlag) break; // Break from inner loop if stop requested

                            appState.stats.totalActions++;
                            ui.progressText.textContent = `${appState.stats.totalActions}`;
                            ui.progressBar.style.width = `100%`;

                            // Gas Price Check (still relevant for skipping if too high, before applying random factor)
                            let currentGasPrice = null;
                            let maxPriorityFeePerGas = null;
                            let maxFeePerGas = null;

                            try {
                                const feeData = await provider.getFeeData();
                                currentGasPrice = feeData.gasPrice; // For legacy transactions
                                maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; // For EIP-1559
                                maxFeePerGas = feeData.maxFeePerGas; // For EIP-1559

                                ui.gasDisplay.textContent = `${(Number(ethers.formatUnits(currentGasPrice || maxFeePerGas, 'gwei'))).toFixed(2)} gwei`;

                                // High Gas Price Multiplier Check
                                const thresholdGasPrice = currentGasPrice ? (currentGasPrice * BigInt(Math.round(appState.config.gasMultiplier * 100))) / BigInt(100) : null;
                                const thresholdMaxFeePerGas = maxFeePerGas ? (maxFeePerGas * BigInt(Math.round(appState.config.gasMultiplier * 100))) / BigInt(100) : null;

                                if ((currentGasPrice && thresholdGasPrice && currentGasPrice > thresholdGasPrice) ||
                                    (maxFeePerGas && thresholdMaxFeePerGas && maxFeePerGas > thresholdMaxFeePerGas)) {
                                    log(`Gas price (${(Number(ethers.formatUnits(currentGasPrice || maxFeePerGas, 'gwei'))).toFixed(2)} gwei) is too high. Skipping action for ...${walletAddress.slice(-6)} on Chain ID ${chainId}.`, 'warning', { chainId, walletAddress, action: 'skipped' });
                                    updateActionDistChart('skipped');
                                    // Breaking the inner loop, will move to the next wallet/chain session.
                                    break;
                                }
                            } catch (gasError) {
                                log(`Failed to get gas price for Chain ID ${chainId}: ${gasError.message}. Proceeding without high gas check.`, 'warning', { chainId, walletAddress, action: 'skipped' });
                            }
                            
                            // Choose action using per-wallet probabilities
                            const chosenBehavior = chooseAction(walletInfo.sessionProbabilities);
                            log(`[Action ${i}/${actionsForWallet}] Wallet ...${walletAddress.slice(-6)} chose to: ${chosenBehavior.toUpperCase()}`, 'info', { chainId, walletAddress, action: chosenBehavior });

                            let actionSuccess = false;
                            switch (chosenBehavior) {
                                case "send":
                                    let recipientAddress;
                                    const currentChainRecipientPool = appState.currentRecipientPool[chainId];
                                    
                                    if (appState.config.recipientMode === 'fixed') {
                                        recipientAddress = ui.fixedAddress.value.trim();
                                        if (!ethers.isAddress(recipientAddress)) {
                                            log(`Fixed recipient address "${recipientAddress}" is invalid. Skipping send.`, 'error', { chainId, walletAddress, action: 'send' });
                                            updateActionDistChart('skipped');
                                            break;
                                        }
                                    } else if (appState.config.recipientMode === 'list') {
                                        if (appState.manualRecipientList.length === 0) {
                                            log(`Recipient list is empty. Skipping send for wallet ...${walletAddress.slice(-6)}.`, 'warning', { chainId, walletAddress, action: 'send' });
                                            updateActionDistChart('skipped');
                                            break;
                                        }
                                        recipientAddress = appState.manualRecipientList[Math.floor(Math.random() * appState.manualRecipientList.length)];
                                    }
                                    else if (appState.config.recipientMode === 'predefined') {
                                        if (appState.predefinedRecipientList.length === 0) {
                                            log(`Predefined recipient list is empty. Skipping send for wallet ...${walletAddress.slice(-6)}.`, 'warning', { chainId, walletAddress, action: 'send' });
                                            updateActionDistChart('skipped');
                                            break;
                                        }
                                        recipientAddress = appState.predefinedRecipientList[Math.floor(Math.random() * appState.predefinedRecipientList.length)];
                                    }
                                    else if (appState.config.recipientMode === 'self-interact') {
                                        const otherWallets = appState.wallets.filter(w => w.address.toLowerCase() !== walletAddress.toLowerCase());
                                        if (otherWallets.length === 0) {
                                            log(`No other loaded wallets to interact with. Skipping send for wallet ...${walletAddress.slice(-6)}.`, 'warning', { chainId, walletAddress, action: 'send' });
                                            updateActionDistChart('skipped');
                                            break;
                                        }
                                        recipientAddress = otherWallets[Math.floor(Math.random() * otherWallets.length)].address;
                                        log(`Sending to another loaded wallet: ${recipientAddress.slice(0,6)}...${recipientAddress.slice(-4)}`, 'info');
                                    }
                                    else if (appState.config.recipientMode === 'pool') {
                                        // Fallback logic for dynamic pool if no external addresses are found for the current chain
                                        if (currentChainRecipientPool && currentChainRecipientPool.length > 0) {
                                            recipientAddress = currentChainRecipientPool[Math.floor(Math.random() * currentChainRecipientPool.length)];
                                        } else {
                                            // If pool is empty, fall back to loaded wallets
                                            const otherWallets = appState.wallets.filter(w => w.address.toLowerCase() !== walletAddress.toLowerCase());
                                            if (otherWallets.length > 0) {
                                                recipientAddress = otherWallets[Math.floor(Math.random() * otherWallets.length)].address;
                                                log(`Dynamic pool empty for Chain ID ${chainId}. Falling back to sending to another loaded wallet: ${recipientAddress.slice(0,6)}...${recipientAddress.slice(-4)}`, 'info');
                                            } else {
                                                log(`Dynamic pool empty and no other loaded wallets to interact with. Skipping send for wallet ...${walletAddress.slice(-6)}.`, 'warning', { chainId, walletAddress, action: 'send' });
                                                updateActionDistChart('skipped');
                                                break;
                                            }
                                        }
                                    } else {
                                        log(`No valid recipient selection for 'send' action. Skipping.`, 'warning', { chainId, walletAddress, action: 'send' });
                                        updateActionDistChart('skipped');
                                        break;
                                    }


                                    const amount = getRandomInRange(appState.config.minAmount, appState.config.maxAmount);
                                    const tx = {
                                        to: recipientAddress,
                                        value: ethers.parseEther(amount.toFixed(12))
                                    };

                                    // Apply random gas factor
                                    const randomGasFactor = getRandomInRange(appState.config.minGasFactor, appState.config.maxGasFactor);
                                    if (maxFeePerGas && maxPriorityFeePerGas) { // EIP-1559 chain
                                        // Apply random factor to base fee and priority fee
                                        tx.maxFeePerGas = (maxFeePerGas * BigInt(Math.round(randomGasFactor * 100))) / BigInt(100);
                                        tx.maxPriorityFeePerGas = (maxPriorityFeePerGas * BigInt(Math.round(randomGasFactor * 100))) / BigInt(100);
                                        // Ensure maxFeePerGas is at least maxPriorityFeePerGas
                                        if (tx.maxFeePerGas < tx.maxPriorityFeePerGas) {
                                            tx.maxFeePerGas = tx.maxPriorityFeePerGas + ethers.parseUnits('1', 'gwei'); // Add a small buffer if needed
                                        }
                                    } else if (currentGasPrice) { // Legacy chain
                                        tx.gasPrice = (currentGasPrice * BigInt(Math.round(randomGasFactor * 100))) / BigInt(100);
                                    }
                                    log(`Attempting to send with random gas factor: x${randomGasFactor.toFixed(2)}`, 'info');

                                    try {
                                        // Simulate random transaction error
                                        if (Math.random() * 100 < appState.config.simulatedErrorChance) {
                                            throw new Error("Simulated network error: Transaction dropped/failed.");
                                        }

                                        log(`Sending ${amount.toFixed(6)} ETH to ${recipientAddress}...`, 'info');
                                        const txResponse = await wallet.sendTransaction(tx);
                                        log(`Tx sent! Hash: <a href="https://etherscan.io/tx/${txResponse.hash}" target="_blank" class="underline">${txResponse.hash}</a><button class="log-copy-btn" data-tx-hash="${txResponse.hash}">📋</button>`, 'success', { chainId, walletAddress, action: 'send' });

                                        await txResponse.wait();
                                        log(`Tx confirmed!`, 'success');
                                        actionSuccess = true;
                                    } catch (error) {
                                        log(`Tx failed: ${error.message}`, 'error', { chainId, walletAddress, action: 'send' });
                                    }
                                    break;

                                case "idle-action":
                                    log(`Wallet ...${walletAddress.slice(-6)} is idling for this action.`, 'info', { chainId, walletAddress, action: 'idle' });
                                    updateActionDistChart('idle');
                                    actionSuccess = true;
                                    break;
                                
                                case "balance-check": // NEW action
                                    try {
                                        const currentBalanceWei = await provider.getBalance(walletAddress);
                                        log(`Wallet ...${walletAddress.slice(-6)} checked balance: ${ethers.formatEther(currentBalanceWei).slice(0, 8)} ETH`, 'info', { chainId, walletAddress, action: 'balance-check' });
                                        actionSuccess = true;
                                    } catch (error) {
                                        log(`Failed to check balance for ...${walletAddress.slice(-6)}: ${error.message}`, 'error', { chainId, walletAddress, action: 'balance-check' });
                                    }
                                    updateActionDistChart('balance-check');
                                    break;
                            }

                            if (actionSuccess) {
                                appState.stats.successfulActions++;
                            } else {
                                appState.stats.failedActions++;
                            }
                            // Update counts on UI immediately after each action attempt
                            ui.successCount.textContent = appState.stats.successfulActions.toString();
                            ui.failCount.textContent = appState.stats.failedActions.toString();
                            updateActionDistChart(chosenBehavior); // Update chart with the chosen behavior

                            try {
                                const newBalanceWei = await provider.getBalance(wallet.address);
                                walletInfo.balance = parseFloat(ethers.formatEther(newBalanceWei)).toFixed(6);
                                updateWalletBalanceChart();
                            } catch (balanceUpdateError) {
                                log(`Failed to update balance for ...${walletInfo.address.slice(-6)}: ${balanceUpdateError.message}`, 'warning');
                            }

                            if (i < actionsForWallet && !appState.stopFlag) {
                                const delay = lnRandomScaled(appState.config.minDelay, appState.config.maxDelay);
                                log(`Waiting for ${Math.round(delay/1000)} seconds before next action...`, 'info');
                                await sleep(delay);
                            }
                        } // End of actionsForWallet loop

                        if (appState.stopFlag) break; // Break main loop if stop requested during inner loop

                        // Delay after a full wallet session on a chain
                        const sessionDelay = lnRandomScaled(appState.config.minDelay, appState.config.maxDelay);
                        log(`Session for Wallet ...${walletAddress.slice(-6)} on Chain ID ${chainId} completed. Waiting for ${Math.round(sessionDelay/1000)} seconds before next session...`, 'info');
                        await sleep(sessionDelay);

                    } // End of while (appState.isRunning && !appState.stopFlag)
                    log('Farming process finished.', 'success');
                    stopFarming();
                });
            };

            const stopFarming = () => {
                appState.isRunning = false;
                appState.stopFlag = true;
                ui.startBtn.disabled = false;
                ui.stopBtn.disabled = true;
                ui.statusDisplay.textContent = 'Idle';
            };

            const clearAllData = () => {
                openConfirmationModal('Are you sure you want to clear ALL configurations, loaded wallets, and log data? This action cannot be undone.', (confirmed) => {
                    if (confirmed) {
                        appState.isRunning = false;
                        appState.stopFlag = false;
                        appState.wallets = [];
                        appState.rpcConfigs = [];
                        appState.currentRecipientPool = {};
                        appState.manualRecipientList = [];
                        ui.listAddresses.value = '';
                        ui.listAddressesCount.textContent = '';
                        appState.predefinedRecipientList = [];
                        ui.predefinedFileInput.value = '';
                        ui.predefinedAddressesInfo.textContent = 'No file loaded.';
                        updatePredefinedAddressesDisplay();
                        appState.config = {};
                        // Updated appState.stats reset for all action types
                        appState.stats = { totalActions: 0, successfulActions: 0, failedActions: 0, actionCounts: { send: 0, idle: 0, 'balance-check': 0, skipped: 0 } };
                        appState.logEntries = [];

                        ui.privateKeys.value = '';
                        ui.rpcUrls.value = `https://mainnet.infura.io/v3/YOUR_PROJECT_ID,1\nhttps://rpc.goerli.dev,5`;
                        ui.probSend.value = "60"; // Reset to new defaults
                        ui.probIdleAction.value = "20"; // Reset to new defaults
                        ui.probBalanceCheck.value = "20"; // Reset to new defaults
                        ui.minGasFactor.value = "0.9";
                        ui.maxGasFactor.value = "1.1";
                        ui.probJitterFactor.value = "5"; // Reset new config
                        ui.simulatedErrorChance.value = "0"; // Reset new config


                        setUIEnabled(false);
                    }
                });
            };

            const handleExplainSendTx = async () => {
                const minAmount = ui.minAmount.value;
                const maxAmount = ui.maxAmount.value;
                const recipientMode = Array.from(ui.recipientMode).find(r => r.checked).value;
                const fixedAddress = ui.fixedAddress.value.trim();
                const listAddressCount = appState.manualRecipientList.length;
                const predefinedAddressCount = appState.predefinedRecipientList.length;
                const loadedWalletCount = appState.wallets.length;


                let recipientDescription = '';
                if (recipientMode === 'fixed' && fixedAddress) {
                    recipientDescription = `a fixed address (${fixedAddress.substring(0, 6)}...)`;
                } else if (recipientMode === 'list' && listAddressCount > 0) {
                    recipientDescription = `a random address from a custom list of ${listAddressCount} addresses`;
                } else if (recipientMode === 'predefined' && predefinedAddressCount > 0) {
                    recipientDescription = `a random address from a predefined list of ${predefinedAddressCount} addresses`;
                } else if (recipientMode === 'self-interact' && loadedWalletCount > 1) {
                    recipientDescription = `a random address from the other ${loadedWalletCount - 1} loaded wallets (excluding the sender)`;
                }
                else {
                    recipientDescription = 'a random address from a dynamically scanned pool (with fallback to loaded wallets if no external addresses are found)';
                }

                const prompt = `I am setting up a script to send Ethereum. The amount will be between ${minAmount} and ${maxAmount} ETH. The recipient will be ${recipientDescription}. Explain the typical purpose of such transactions in a blockchain context and any general risks a user should be aware of.`;
                await callGeminiApi(prompt);
            };


            const downloadLog = () => {
                if (appState.logEntries.length === 0) {
                    openGeminiModal('No Data', '<p class="text-accent">No log data to download.</p>');
                    return;
                }

                const headers = Object.keys(appState.logEntries[0]).join(',');
                const rows = appState.logEntries.map(entry =>
                    Object.values(entry).map(value => `"${String(value).replace(/"/g, '""')}"`).join(',')
                );

                const csvContent = headers + '\n' + rows.join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `tx_log_${new Date().toISOString().slice(0,10)}.csv`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            const copyToClipboard = (text) => {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'absolute';
                textarea.style.left = '-9999px';
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    log(`Copied "${text}" to clipboard.`, 'info');
                } catch (err) {
                    log('Failed to copy to clipboard (unsupported by browser/iframe).', 'error');
                }
                document.body.removeChild(textarea);
            };

            const connectWallet = async () => {
                if (typeof window.ethereum === 'undefined') {
                    log('MetaMask or compatible wallet not detected. Please install one.', 'error');
                    ui.walletStatusDisplay.innerHTML = `No wallet detected. Please install <a href="https://metamask.io/" target="_blank" class="underline text-blue-500">MetaMask</a> or a compatible browser extension.`;
                    setUIEnabled(false);
                    return;
                }

                log('window.ethereum detected. Requesting accounts...', 'info');
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });

                    if (accounts.length === 0) {
                        log('No accounts found. Please connect your wallet and select an account.', 'error');
                        appState.connectedAddress = null;
                        ui.walletStatusDisplay.innerHTML = `No wallet connected.`;
                        setUIEnabled(false);
                        return;
                    }
                    appState.connectedAddress = accounts[0];
                    log(`Wallet connected: ${appState.connectedAddress}`, 'success');
                    ui.walletStatusDisplay.innerHTML = `Connected: <strong>${appState.connectedAddress.slice(0, 6)}...${appState.connectedAddress.slice(-4)}</strong>`;
                    setUIEnabled(true);

                    // Set up event listeners for window.ethereum
                    window.ethereum.on('accountsChanged', (newAccounts) => {
                        log('Wallet accounts changed event detected.', 'info');
                        if (newAccounts.length === 0) {
                            log('Wallet disconnected or no accounts selected.', 'warning');
                            appState.connectedAddress = null;
                            ui.walletStatusDisplay.innerHTML = `No wallet connected.`;
                            setUIEnabled(false);
                        } else if (appState.connectedAddress && newAccounts[0].toLowerCase() !== appState.connectedAddress.toLowerCase()) {
                            log(`Account changed to: ${newAccounts[0]}`, 'info');
                            appState.connectedAddress = newAccounts[0];
                            ui.walletStatusDisplay.innerHTML = `Connected: <strong>${appState.connectedAddress.slice(0, 6)}...${appState.connectedAddress.slice(-4)}</strong>`;
                            setUIEnabled(true);
                        } else if (!appState.connectedAddress) {
                            log(`Wallet reconnected with account: ${newAccounts[0]}`, 'info');
                            appState.connectedAddress = newAccounts[0];
                            ui.walletStatusDisplay.innerHTML = `Connected: <strong>${appState.connectedAddress.slice(0, 6)}...${appState.connectedAddress.slice(-4)}</strong>`;
                            setUIEnabled(true);
                        }
                    });

                    window.ethereum.on('chainChanged', (chainId) => {
                        log(`Network changed to Chain ID: ${parseInt(chainId, 16)}. Please ensure your RPC configurations match this network.`, 'warning');
                    });

                    window.ethereum.on('disconnect', (error) => {
                        log(`Wallet disconnected: ${error.message || 'Unknown error'}`, 'error');
                        appState.connectedAddress = null;
                        ui.walletStatusDisplay.innerHTML = `No wallet connected.`;
                        setUIEnabled(false);
                    });

                } catch (error) {
                    log(`Wallet connection failed: ${error.message}`, 'error');
                    appState.connectedAddress = null;
                    ui.walletStatusDisplay.innerHTML = `Connection failed.`;
                    setUIEnabled(false);
                }
            };

            // This function now solely manages which of the two main content areas is visible.
            // It does not handle scrolling or active link states in the navigation bar directly.
            const showMainContentArea = (pageId) => {
                ui.scriptConsoleContent.classList.add('hidden');
                ui.infographicContent.classList.add('hidden');

                if (pageId === 'console') {
                    ui.scriptConsoleContent.classList.remove('hidden');
                } else if (pageId === 'infographic') {
                    ui.infographicContent.classList.remove('hidden');
                    // Initialize infographic charts only when the page is shown
                    initInfographicActionDistChart();
                    initInfographicWalletBalanceChart();
                    initInfographicGasPriceChart();
                }
            };

            const setupEventListeners = () => {
                ui.connectWalletBtn.addEventListener('click', connectWallet);
                ui.startBtn.addEventListener('click', startFarming);
                ui.stopBtn.addEventListener('click', stopFarming);
                ui.clearAllDataBtn.addEventListener('click', clearAllData);
                ui.loadKeysBtn.addEventListener('click', loadWallets);
                ui.testRpcBtn.addEventListener('click', testRpcConnections);
                ui.downloadLogBtn.addEventListener('click', downloadLog);
                ui.explainSendTxBtn.addEventListener('click', handleExplainSendTx);
                ui.loadAddressesFromListBtn.addEventListener('click', loadAddressesFromList);
                ui.loadPredefinedFileBtn.addEventListener('click', loadPredefinedListFromFile);
                
                ui.closeModalBtn.addEventListener('click', closeGeminiModal);
                window.addEventListener('click', (event) => {
                    if (event.target === ui.geminiModal) {
                        closeGeminiModal();
                    }
                });

                ui.confirmActionBtn.addEventListener('click', confirmAction);
                ui.cancelConfirmBtn.addEventListener('click', cancelAction);
                ui.closeConfirmBtn.addEventListener('click', cancelAction);
                window.addEventListener('click', (event) => {
                    if (event.target === ui.confirmationModal) {
                        cancelAction();
                    }
                });

                ui.liveLog.addEventListener('click', (event) => {
                    const copyBtn = event.target.closest('.log-copy-btn');
                    if (copyBtn && copyBtn.dataset.txHash) {
                        copyToClipboard(copyBtn.dataset.txHash);
                    }
                });


                ui.recipientMode.forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        ui.fixedAddressSection.classList.toggle('hidden', e.target.value !== 'fixed');
                        ui.listAddressesSection.classList.toggle('hidden', e.target.value !== 'list');
                        ui.predefinedAddressesSection.classList.toggle('hidden', e.target.value !== 'predefined');
                        loadConfiguration();
                    });
                });

                // Only attach event listeners to relevant probability inputs
                document.querySelectorAll('#prob-send, #prob-idle-action, #prob-balance-check').forEach(input => {
                    input.addEventListener('input', loadConfiguration);
                });

                ui.minAmount.addEventListener('input', loadConfiguration);
                ui.maxAmount.addEventListener('input', loadConfiguration);
                ui.minDelay.addEventListener('input', loadConfiguration);
                ui.maxDelay.addEventListener('input', loadConfiguration);
                ui.minGasFactor.addEventListener('input', loadConfiguration);
                ui.maxGasFactor.addEventListener('input', loadConfiguration);
                ui.probJitterFactor.addEventListener('input', loadConfiguration); // NEW
                ui.simulatedErrorChance.addEventListener('input', loadConfiguration); // NEW
                
                ui.navLinks.forEach(link => {
                    link.addEventListener('click', function(e) {
                         e.preventDefault(); // Prevent default anchor behavior to control the scroll

                         const targetPage = this.dataset.page; // 'console' or 'infographic'
                         const targetHref = this.getAttribute('href'); // e.g., '#dashboard', '#overview'
                         const targetElementId = targetHref.substring(1); // Remove '#'
                         const targetElement = document.getElementById(targetElementId);

                         // First, ensure the correct main content area is visible
                         showMainContentArea(targetPage);

                         // Then, smoothly scroll to the specific target element within that content area
                         // Add a small delay for the display change to render properly before scrolling
                         setTimeout(() => {
                             if (targetElement) {
                                 targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                             }
                         }, 100); // 100ms delay should be sufficient

                         // Update the active class for the clicked navigation link
                         ui.navLinks.forEach(navLink => navLink.classList.remove('active'));
                         this.classList.add('active');
                    });
                });
            };

            initConsoleCharts(); // Initialize charts for the console
            setupEventListeners();
            loadConfiguration();
            updateWalletBalanceChart();
            setUIEnabled(false);

            // Set the initial active navigation link and display the default content area
            const initialPage = 'console'; // Default starting page
            showMainContentArea(initialPage);
            const initialActiveLink = document.querySelector(`.nav-link[data-page="${initialPage}"][href="#dashboard"]`); // Assuming Dashboard is the initial section in Console
            if (initialActiveLink) {
                initialActiveLink.classList.add('active');
            }


            // Initial check for window.ethereum and existing connection on page load
            if (typeof window.ethereum !== 'undefined') {
                 log('MetaMask or compatible wallet detected on startup. Checking for existing connection...', 'info');
                 window.ethereum.request({ method: 'eth_accounts' })
                    .then(accounts => {
                        if (accounts.length > 0) {
                            appState.connectedAddress = accounts[0];
                            log(`Existing wallet connection found: ${appState.connectedAddress}`, 'info');
                            ui.walletStatusDisplay.innerHTML = `Connected: <strong>${appState.connectedAddress.slice(0, 6)}...${appState.connectedAddress.slice(-4)}</strong>`;
                            setUIEnabled(true);
                        } else {
                             ui.walletStatusDisplay.innerHTML = `No wallet connected.`;
                             log('No existing wallet connection found on startup.', 'info');
                        }
                    })
                    .catch(error => {
                        log(`Error checking existing wallet connection: ${error.message}`, 'error');
                         ui.walletStatusDisplay.innerHTML = `Error: ${error.message}`;
                    });

                 window.ethereum.on('accountsChanged', (newAccounts) => {
                     log('Wallet accounts changed event detected (startup listener).', 'info');
                     if (newAccounts.length === 0) {
                         log('Wallet disconnected or no accounts selected (startup listener).', 'warning');
                         appState.connectedAddress = null;
                         ui.walletStatusDisplay.innerHTML = `No wallet connected.`;
                         setUIEnabled(false);
                     } else {
                         log(`Account changed to: ${newAccounts[0]} (startup listener)`, 'info');
                         appState.connectedAddress = newAccounts[0];
                         ui.walletStatusDisplay.innerHTML = `Connected: <strong>${appState.connectedAddress.slice(0, 6)}...${appState.connectedAddress.slice(-4)}</strong>`;
                         setUIEnabled(true);
                     }
                 });

                 window.ethereum.on('chainChanged', (chainId) => {
                     log(`Network changed to Chain ID: ${parseInt(chainId, 16)} (startup listener). Please ensure RPCs match.`, 'warning');
                 });

                 window.ethereum.on('disconnect', (error) => {
                    log(`Wallet disconnected: ${error.message || 'Unknown error'} (startup listener)`, 'error');
                    appState.connectedAddress = null;
                    ui.walletStatusDisplay.innerHTML = `No wallet connected.`;
                    setUIEnabled(false);
                });

            } else {
                ui.walletStatusDisplay.innerHTML = `No wallet detected. Please install <a href="https://metamask.io/" target="_blank" class="underline text-blue-500">MetaMask</a>.`;
                log('MetaMask or compatible wallet not detected on startup.', 'error');
            }

            log('Console initialized. Please connect your wallet to begin.');

            // --- NEW FOOTER FUNCTIONALITY ---
            const donationAddressStr = '0x1C46ccEA4D62d3eEC4DCE3501aa96d0Ff5FcA954';
            const copyBtn = document.getElementById('copy-address-btn');
            const copyIcon = document.getElementById('copy-icon');
            const checkIcon = document.getElementById('check-icon');
            const showQrBtn = document.getElementById('show-qr-btn');
            const qrModal = document.getElementById('qr-code-modal');
            const closeQrModalBtn = qrModal.querySelector('.close-qr-button');
            const qrCodeContainer = document.getElementById('qr-code-container');
            const qrAddressDisplay = document.getElementById('qr-address-display');

            // Initialize QR Code once
            if(typeof QRCode !== 'undefined') {
                new QRCode(qrCodeContainer, {
                    text: donationAddressStr,
                    width: 200,
                    height: 200,
                    colorDark : "#2d3748",
                    colorLight : "#ffffff",
                    correctLevel : QRCode.CorrectLevel.H
                });
                qrAddressDisplay.textContent = donationAddressStr;
            } else {
                console.error("QRCode library is not loaded.")
                qrCodeContainer.innerHTML = "QR Code library failed to load. Please check your connection.";
            }

            // Copy to clipboard
            copyBtn.addEventListener('click', () => {
                copyToClipboard(donationAddressStr);
                copyIcon.classList.add('hidden');
                checkIcon.classList.remove('hidden');
                setTimeout(() => {
                    copyIcon.classList.remove('hidden');
                    checkIcon.classList.add('hidden');
                }, 2000);
            });

            // Show QR Modal
            showQrBtn.addEventListener('click', () => {
                qrModal.classList.remove('hidden');
            });

            // Close QR Modal logic
            const closeQrModal = () => {
                qrModal.classList.add('hidden');
            }
            closeQrModalBtn.addEventListener('click', closeQrModal);
            window.addEventListener('click', (event) => {
                if (event.target === qrModal) {
                    closeQrModal();
                }
            });
        });
    </script>
</body>
</html>
