<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basic Interactive Script Console (Non-Blocking TX)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Custom Styles for aesthetics and responsiveness */
        :root {
            --bg-primary-light: #f4f1eb; /* Warm Beige */
            --bg-secondary-light: #ffffff;
            --text-main-light: #212529;
            --brand-color: #3b82f6; /* Blue 500 */
            --danger-color: #ef4444; /* Red 500 */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary-light);
            color: var(--text-main-light);
            min-height: 100vh;
        }
        .card {
            background-color: var(--bg-secondary-light);
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .btn-primary {
            background-color: var(--brand-color);
            transition: background-color 0.15s;
        }
        .btn-primary:hover {
            background-color: #2563eb; /* Blue 600 */
        }
        .btn-secondary {
            background-color: #f3f4f6;
            color: #374151;
            transition: background-color 0.15s;
        }
        .btn-secondary:hover {
            background-color: #e5e7eb;
        }
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield;
        }
        /* Style for the console output */
        #console-output {
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        /* Modal backdrop for QR Code */
        .modal {
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        .explorer-link {
            color: #3b82f6;
            text-decoration: underline;
            cursor: pointer;
        }
    </style>
</head>
<body class="p-4 sm:p-8 flex flex-col items-center">

    <div class="max-w-4xl w-full">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-extrabold text-gray-800">EVM Transaction Console</h1>
            <p class="text-gray-600 mt-2">Connect, send, and analyze Ethereum transactions. **$0$ value transactions are now enabled.**</p>
        </header>

        <!-- Connection and Status Card -->
        <div class="card p-6 mb-8">
            <h2 class="text-2xl font-bold mb-4 border-b pb-2 text-gray-700">Wallet Status</h2>
            <div id="status-display" class="space-y-3">
                <p><strong>Status:</strong> <span id="connection-status" class="text-red-500">Disconnected</span></p>
                <!-- Added Chain ID Display -->
                <p><strong>Network:</strong> <span id="network-display">N/A</span></p>
                <p><strong>Chain ID:</strong> <span id="chain-id-display">N/A</span></p>
                <p><strong>Address:</strong> <span id="address-display" class="font-mono text-sm break-all">Connect Wallet First</span></p>
                <p><strong>Balance:</strong> <span id="balance-display">N/A</span></p>
            </div>
            <button id="connect-wallet-btn" class="w-full mt-4 btn-primary text-white py-3 px-4 rounded-xl font-semibold shadow-md hover:shadow-lg">
                Connect Wallet (MetaMask / EIP-1193)
            </button>
        </div>

        <!-- Transaction Card -->
        <div class="card p-6 mb-8">
            <h2 class="text-2xl font-bold mb-4 border-b pb-2 text-gray-700">Send Transaction (Manual)</h2>
            <div class="space-y-4">
                <div>
                    <label for="recipient-input" class="block text-sm font-medium text-gray-700">Recipient Address</label>
                    <input type="text" id="recipient-input" placeholder="0x..." class="mt-1 block w-full border border-gray-300 rounded-xl shadow-sm p-3 focus:ring-blue-500 focus:border-blue-500 font-mono">
                </div>
                
                <!-- New Recipient Buttons -->
                <div class="flex space-x-2">
                    <button id="self-send-btn" class="flex-1 btn-secondary text-gray-700 py-2 px-3 rounded-xl font-medium shadow-sm hover:shadow-md transition">
                        <i class="fas fa-undo mr-1"></i> Self-Send
                    </button>
                    <button id="dead-address-btn" class="flex-1 bg-red-100 text-red-700 py-2 px-3 rounded-xl font-medium shadow-sm hover:bg-red-200 transition">
                        <i class="fas fa-trash-alt mr-1"></i> Send to Burn Address
                    </button>
                </div>

                <div>
                    <label for="amount-input" class="block text-sm font-medium text-gray-700">Amount (ETH/Token) - **Min $0$**</label>
                    <input type="number" id="amount-input" value="0.000" min="0" step="0.000000000000000001" placeholder="0.000" class="mt-1 block w-full border border-gray-300 rounded-xl shadow-sm p-3 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div>
                    <label for="data-input" class="block text-sm font-medium text-gray-700">Transaction Data (Optional Hex)</label>
                    <input type="text" id="data-input" placeholder="0x..." class="mt-1 block w-full border border-gray-300 rounded-xl shadow-sm p-3 focus:ring-blue-500 focus:border-blue-500 font-mono">
                </div>
                <button id="send-transaction-btn" class="w-full btn-primary text-white py-3 px-4 rounded-xl font-semibold shadow-md hover:shadow-lg disabled:bg-gray-400" disabled>
                    <i class="fas fa-paper-plane mr-2"></i> Send Transaction
                </button>
            </div>
        </div>

        <!-- Automated Transaction Sender Card -->
        <div class="card p-6 mb-8">
            <h2 class="text-2xl font-bold mb-4 border-b pb-2 text-gray-700">Automated Transaction Sender</h2>
            <p class="text-gray-600 mb-4">Repeatedly sends the transaction defined above with a random delay between attempts. Transactions are **sent but confirmations are monitored in the background** to prevent blocking the loop.</p>
            <div class="space-y-4">
                <!-- Delay Inputs -->
                <div class="flex space-x-4">
                    <div class="flex-1">
                        <label for="min-delay-input" class="block text-sm font-medium text-gray-700">Min Delay (seconds)</label>
                        <input type="number" id="min-delay-input" value="10" min="1" class="mt-1 block w-full border border-gray-300 rounded-xl shadow-sm p-3 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div class="flex-1">
                        <label for="max-delay-input" class="block text-sm font-medium text-gray-700">Max Delay (seconds)</label>
                        <input type="number" id="max-delay-input" value="20" min="1" class="mt-1 block w-full border border-gray-300 rounded-xl shadow-sm p-3 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                </div>
                
                <button id="toggle-auto-send-btn" class="w-full bg-green-500 text-white py-3 px-4 rounded-xl font-semibold shadow-md hover:bg-green-600 disabled:bg-gray-400" disabled>
                    <i class="fas fa-play mr-2"></i> Start Auto-Send Loop
                </button>
            </div>
        </div>
        <!-- End Automated Transaction Sender Card -->


        <!-- Console Output Card -->
        <div class="card p-6 mb-8">
            <h2 class="text-2xl font-bold mb-4 border-b pb-2 text-gray-700">Console Output</h2>
            <div id="console-output" class="bg-gray-800 text-green-400 p-4 rounded-lg text-sm">
                Awaiting wallet connection...
            </div>
        </div>

        <!-- Donation Section (Original from snippet) -->
        <div class="card p-6 text-center mb-8">
            <h2 class="text-xl font-bold text-gray-700 mb-4">Support This Tool</h2>
            <p class="text-gray-600 mb-4">You can support the development of this tool by sending a small amount to the address below.</p>
            <button id="show-qr-btn" class="bg-yellow-500 text-white py-2 px-4 rounded-xl font-semibold shadow-md hover:bg-yellow-600 transition">
                Show Donation QR
            </button>
        </div>

    </div>

    <!-- QR Code Modal (Original from snippet) -->
    <div id="qr-modal" class="modal fixed inset-0 flex items-center justify-center z-50 hidden p-4">
        <div class="bg-white p-8 rounded-xl shadow-2xl max-w-sm w-full relative">
            <button id="close-qr-modal-btn" class="absolute top-3 right-3 text-gray-500 hover:text-gray-800">
                <i class="fas fa-times text-xl"></i>
            </button>
            <h3 class="text-xl font-bold text-center mb-4">Donation Address</h3>
            <div id="qr-code-container" class="flex justify-center mb-4"></div>
            <p id="qr-address-display" class="font-mono text-center break-all text-sm mb-4"></p>
            <button id="copy-address-btn" class="w-full btn-primary text-white py-2 rounded-xl font-semibold flex items-center justify-center space-x-2">
                <i id="copy-icon" class="fas fa-copy"></i>
                <i id="check-icon" class="fas fa-check text-green-400 hidden"></i>
                <span>Copy Address</span>
            </button>
        </div>
    </div>


    <script>
        // --- Global Variables & Initialization ---
        let provider = null;
        let signer = null;
        let userAddress = null;
        let userBalance = 0n; // Use BigInt for balance
        let chainId = null; 
        const donationAddressStr = "0xdAC34f55a10A0A9b82F9e4d588526553A577717E"; // Placeholder address
        const deadAddress = "0x0000000000000000000000000000000000000000"; // The standard burn address
        
        // Auto-Send Variables
        let autoSendTimeoutId = null; 
        let isAutoSending = false; 

        // DOM elements
        const connectWalletBtn = document.getElementById('connect-wallet-btn');
        const sendTransactionBtn = document.getElementById('send-transaction-btn');
        const statusDisplay = document.getElementById('connection-status');
        const networkDisplay = document.getElementById('network-display');
        const chainIdDisplay = document.getElementById('chain-id-display'); 
        const addressDisplay = document.getElementById('address-display');
        const balanceDisplay = document.getElementById('balance-display');
        const recipientInput = document.getElementById('recipient-input');
        const amountInput = document.getElementById('amount-input');
        const dataInput = document.getElementById('data-input');
        const consoleOutput = document.getElementById('console-output');
        
        // New Recipient Buttons
        const selfSendBtn = document.getElementById('self-send-btn');
        const deadAddressBtn = document.getElementById('dead-address-btn');
        
        // New Auto-Send DOM elements
        const minDelayInput = document.getElementById('min-delay-input');
        const maxDelayInput = document.getElementById('max-delay-input');
        const toggleAutoSendBtn = document.getElementById('toggle-auto-send-btn');


        // QR Modal elements
        const qrModal = document.getElementById('qr-modal');
        const qrCodeContainer = document.getElementById('qr-code-container');
        const qrAddressDisplay = document.getElementById('qr-address-display');
        const copyBtn = document.getElementById('copy-address-btn');
        const copyIcon = document.getElementById('copy-icon');
        const checkIcon = document.getElementById('check-icon');
        const showQrBtn = document.getElementById('show-qr-btn');
        const closeQrModalBtn = document.getElementById('close-qr-modal-btn');

        // Map common chain IDs to their block explorers (using BigInt keys for ethers v6)
        const chainExplorers = {
            1n: 'https://etherscan.io/tx/',        // Ethereum Mainnet
            5n: 'https://goerli.etherscan.io/tx/',    // Goerli (Legacy)
            11155111n: 'https://sepolia.etherscan.io/tx/', // Sepolia
            137n: 'https://polygonscan.com/tx/',    // Polygon Mainnet
            80001n: 'https://mumbai.polygonscan.com/tx/', // Polygon Mumbai (Legacy)
            42161n: 'https://arbiscan.io/tx/',      // Arbitrum One
            10n: 'https://optimistic.etherscan.io/tx/', // Optimism
            56n: 'https://bscscan.com/tx/',        // BNB Smart Chain
            43114n: 'https://snowtrace.io/tx/',     // Avalanche C-Chain
            250n: 'https://ftmscan.com/tx/',        // Fantom Opera
        };

        /**
         * Gets the appropriate block explorer URL for the current chain.
         * @param {bigint} currentChainId The current chain ID.
         * @param {string} txHash The transaction hash.
         * @returns {string} The full transaction explorer URL.
         */
        function getExplorerUrl(currentChainId, txHash) {
            const baseUrl = chainExplorers[currentChainId] || `https://etherscan.io/tx/`;
            return `${baseUrl}${txHash}`;
        }

        // --- Utility Functions ---

        /**
         * Appends a message to the console output.
         * @param {string} message The message to display.
         * @param {string} type The type of message (log, error, success, warn, info, pending).
         */
        function log(message, type = 'log') {
            const time = new Date().toLocaleTimeString();
            let color = 'text-green-400';
            if (type === 'error') color = 'text-red-400';
            if (type === 'warn') color = 'text-yellow-400';
            if (type === 'info') color = 'text-blue-400';
            if (type === 'pending') color = 'text-purple-400'; 
            
            const element = document.createElement('span');
            element.className = color + ' block';
            
            if (message.startsWith('Explorer Link: ')) {
                const url = message.substring('Explorer Link: '.length);
                const prefix = `[${time}] [INFO] Explorer Link: `;
                
                const prefixSpan = document.createElement('span');
                prefixSpan.textContent = prefix;
                
                const linkAnchor = document.createElement('a');
                linkAnchor.href = url;
                linkAnchor.target = '_blank';
                linkAnchor.textContent = url;
                linkAnchor.className = 'explorer-link'; 
                
                element.appendChild(prefixSpan);
                element.appendChild(linkAnchor);
            } else {
                element.textContent = `[${time}] [${type.toUpperCase()}] ${message}`;
            }
            
            consoleOutput.appendChild(element);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
        }

        /**
         * Copies text to the clipboard.
         * @param {string} text The text to copy.
         */
        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                log('Address copied to clipboard.', 'info');
            } catch (err) {
                log('Failed to copy text.', 'error');
            }
            document.body.removeChild(textarea);
        }

        /**
         * Updates the wallet status in the UI.
         */
        function updateStatus() {
            if (userAddress) {
                statusDisplay.textContent = 'Connected';
                statusDisplay.className = 'text-green-500 font-semibold';
                addressDisplay.textContent = userAddress;
                balanceDisplay.textContent = userBalance ? `${ethers.formatEther(userBalance)} ETH` : '0 ETH';
                chainIdDisplay.textContent = chainId !== null ? chainId.toString() : 'N/A';
                sendTransactionBtn.disabled = isAutoSending; // Disable single send if auto-sending
                toggleAutoSendBtn.disabled = false; // Enable auto-send button
            } else {
                statusDisplay.textContent = 'Disconnected';
                statusDisplay.className = 'text-red-500';
                networkDisplay.textContent = 'N/A';
                chainIdDisplay.textContent = 'N/A';
                addressDisplay.textContent = 'Connect Wallet First';
                balanceDisplay.textContent = 'N/A';
                sendTransactionBtn.disabled = true;
                toggleAutoSendBtn.disabled = true;
                stopAutoSend(); // Ensure loop is stopped on disconnect
            }
        }
        
        // --- Auto-Send Logic ---

        /**
         * Generates a random delay in milliseconds between min and max seconds.
         * @param {number} minS Minimum delay in seconds.
         * @param {number} maxS Maximum delay in seconds.
         * @returns {number} Random delay in milliseconds.
         */
        function getRandomDelay(minS, maxS) {
            const minMs = minS * 1000;
            const maxMs = maxS * 1000;
            return Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
        }

        /**
         * Stops the auto-send loop.
         */
        function stopAutoSend() {
            if (!isAutoSending) return;

            clearTimeout(autoSendTimeoutId);
            autoSendTimeoutId = null;
            isAutoSending = false;

            // Update UI
            toggleAutoSendBtn.textContent = 'Start Auto-Send Loop';
            toggleAutoSendBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
            toggleAutoSendBtn.classList.add('bg-green-500', 'hover:bg-green-600');

            updateStatus(); 
            
            log('Auto-Send Loop Stopped.', 'warn');
        }

        /**
         * The core logic for the automated send loop.
         */
        async function autoSendLoop() {
            if (!isAutoSending || !signer) {
                stopAutoSend();
                return;
            }

            const minDelay = parseInt(minDelayInput.value, 10);
            const maxDelay = parseInt(maxDelayInput.value, 10);
            const recipient = recipientInput.value.trim();
            const amountStr = amountInput.value.trim() || '0';
            const data = dataInput.value.trim() || '0x';

            if (!recipient || isNaN(parseFloat(amountStr)) || parseFloat(amountStr) < 0 || minDelay <= 0 || maxDelay <= 0 || minDelay > maxDelay) {
                log('Invalid transaction or delay settings for auto-send. Stopping loop.', 'error');
                stopAutoSend();
                return;
            }

            log(`Auto-Send: Attempting transaction...`, 'info');
            
            // Use the core send function, skipping confirmation wait
            const txResponse = await coreSendTransaction(recipient, amountStr, data, true); 

            if (txResponse) {
                // If broadcast was successful, schedule the next iteration based on the timer
                const delayMs = getRandomDelay(minDelay, maxDelay);
                log(`Auto-Send: TX ${txResponse.hash.slice(0, 10)}... sent. Next scheduled in ${delayMs / 1000}s.`, 'pending');
                
                // Fire and forget confirmation monitor
                // The monitorConfirmation function already handles the fetchAccountData call on success/failure
                monitorConfirmation(txResponse.hash);
                
                autoSendTimeoutId = setTimeout(autoSendLoop, delayMs);
            } else {
                // If send failed (e.g., user rejected, insufficient funds), wait before retrying or stopping
                log('Auto-Send: Transaction failed to broadcast. Retrying in 5s.', 'error');
                autoSendTimeoutId = setTimeout(autoSendLoop, 5000); 
            }
        }

        /**
         * Toggles the auto-send state.
         */
        function toggleAutoSend() {
            if (isAutoSending) {
                stopAutoSend();
            } else {
                startAutoSend();
            }
        }
        
        /**
         * Starts the auto-send loop.
         */
        function startAutoSend() {
            if (!signer) {
                log('Please connect your wallet first.', 'warn');
                return;
            }
            
            const minDelay = parseInt(minDelayInput.value, 10);
            const maxDelay = parseInt(maxDelayInput.value, 10);

            if (minDelay <= 0 || maxDelay <= 0 || minDelay > maxDelay) {
                log('Invalid delay settings. Min must be $\\leq$ Max and both must be $\\geq 1$ second.', 'error');
                return;
            }

            isAutoSending = true;
            
            // Update UI
            toggleAutoSendBtn.textContent = 'Stop Auto-Send Loop';
            toggleAutoSendBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
            toggleAutoSendBtn.classList.add('bg-red-500', 'hover:bg-red-600');
            
            updateStatus(); 

            log('Auto-Send Loop Started. Transactions will be sent with random delays.', 'success');
            
            // Start the first iteration immediately
            autoSendLoop();
        }

        // --- Core Application Logic ---

        /**
         * Fetches and updates the user's balance and network info.
         */
        async function fetchAccountData() {
            if (!provider || !userAddress) return;

            try {
                // Get Balance
                const balance = await provider.getBalance(userAddress);
                userBalance = balance;

                // Get Network & Chain ID
                const network = await provider.getNetwork();
                networkDisplay.textContent = network.name || 'Unknown Network';
                chainId = network.chainId; 
                chainIdDisplay.textContent = chainId !== null ? chainId.toString() : 'N/A';

                updateStatus();
                log(`Account data refreshed. Balance: ${ethers.formatEther(userBalance)} ETH. Chain ID: ${chainId}`, 'info');

            } catch (error) {
                log(`Error fetching account data: ${error.message}`, 'error');
            }
        }

        /**
         * Connects the wallet using window.ethereum (MetaMask/EIP-1193).
         */
        async function connectWallet() {
            if (typeof window.ethereum === 'undefined') {
                log('MetaMask or other EIP-1193 compatible wallet not found.', 'error');
                return;
            }

            try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                userAddress = accounts[0];

                provider = new ethers.BrowserProvider(window.ethereum);
                signer = await provider.getSigner();

                log('Wallet connected successfully.', 'success');
                await fetchAccountData();

                // Auto-refresh balance every 15 seconds
                setInterval(fetchAccountData, 15000); 

                // Event listeners for account/chain changes
                window.ethereum.on('accountsChanged', (accounts) => {
                    userAddress = accounts.length > 0 ? accounts[0] : null;
                    if (userAddress) {
                        signer = provider.getSigner();
                        fetchAccountData();
                    } else {
                        provider = null;
                        signer = null;
                        updateStatus();
                        log('Wallet disconnected.', 'warn');
                    }
                });

                window.ethereum.on('chainChanged', () => {
                    log('Network changed. Re-fetching data...', 'warn');
                    fetchAccountData();
                });

            } catch (error) {
                log(`Connection failed: ${error.message}`, 'error');
                userAddress = null;
                updateStatus();
            }
        }

        /**
         * Waits for the transaction confirmation and logs the result.
         * This function is non-blocking to the main send logic.
         * @param {string} txHash The transaction hash to monitor.
         */
        async function monitorConfirmation(txHash) {
            try {
                log(`Waiting for confirmation of TX ${txHash.slice(0, 10)}...`, 'pending');

                const txReceipt = await provider.waitForTransaction(txHash);

                // Use 1n (BigInt) for comparison as per ethers v6 standard
                if (txReceipt && txReceipt.status === 1n) {
                    log(`Confirmation SUCCESS: TX ${txHash.slice(0, 10)}... confirmed in block ${txReceipt.blockNumber}`, 'success');
                    log(`Explorer Link: ${getExplorerUrl(chainId, txHash)}`, 'info');
                } else {
                    log(`Confirmation FAILED: TX ${txHash.slice(0, 10)}... failed or reverted.`, 'error');
                }
                
                await fetchAccountData(); 
            } catch (err) {
                 // Handle explicit errors during waiting (e.g., node disconnection, timeout)
                log(`Error monitoring confirmation for TX ${txHash.slice(0, 10)}...: ${err.message}`, 'error');
            }
        }

        /**
         * Signs and sends the transaction, but can optionally skip waiting for confirmation.
         * @param {string} recipient The recipient address.
         * @param {string} amountStr The amount string (e.g., '0.001').
         * @param {string} data The transaction data (e.g., '0x').
         * @param {boolean} skipConfirm If true, returns immediately after broadcasting.
         * @returns {Promise<ethers.TransactionResponse | null>} The transaction response if sent, null otherwise.
         */
        async function coreSendTransaction(recipient, amountStr, data, skipConfirm = false) {
            if (!signer) {
                log('No connected signer. Connect your wallet first.', 'error');
                return null;
            }

            try {
                // Ensure amount is parsed correctly, defaulting to 0
                const txValue = ethers.parseEther(amountStr || "0"); 
                const txData = data && data !== '' ? data : "0x";

                const txRequest = {
                    to: recipient,
                    value: txValue,
                    data: txData,
                };
                
                log('Estimating gas limits and costs...', 'info');

                let gasLimit;
                try {
                    gasLimit = await provider.estimateGas(txRequest);
                } catch (gasError) {
                    gasLimit = 21000n; // Fallback to base ETH transfer limit (21,000 Wei)
                    log(`Gas estimation failed (${gasError.message}). Using default ${gasLimit.toString()}.`, 'warn');
                }
                txRequest.gasLimit = gasLimit;

                log('Sending transaction to wallet for confirmation...', 'warn');

                // This line waits for the user to approve the transaction, then returns the broadcasted response.
                const txResponse = await signer.sendTransaction(txRequest);
                log(`Transaction broadcasted: ${txResponse.hash}`, 'pending');
                
                // If not skipping confirmation (i.e., manual send), start the non-blocking monitor.
                if (!skipConfirm) {
                    await monitorConfirmation(txResponse.hash);
                }

                return txResponse;

            } catch (error) {
                let errorMessage = error.message;

                if (error.code === 'INSUFFICIENT_FUNDS') {
                    errorMessage = 'Insufficient funds to cover the transaction fees (gas).';
                } else if (error.code === 'ACTION_REJECTED' || error.message.includes('user rejected')) {
                    errorMessage = 'Transaction rejected by the user in the wallet.';
                } else if (error.message.includes('invalid address')) {
                    errorMessage = 'Invalid recipient address.';
                }

                log(`Transaction failed to broadcast: ${errorMessage}`, 'error');
                return null;
            }
        }

        /**
         * Wrapper for single-click transaction sending (calls core function).
         */
        async function handleSingleSend() {
            const recipient = recipientInput.value.trim();
            const amountStr = amountInput.value.trim() || '0';
            const data = dataInput.value.trim() || '0x';

            // 1. Basic Input Validation
            if (!recipient) {
                log('Recipient address is required.', 'error');
                return;
            }
            if (isNaN(parseFloat(amountStr)) || parseFloat(amountStr) < 0) {
                 log('Invalid amount entered. Amount must be $0$ or greater.', 'error');
                 return;
            }
            
            sendTransactionBtn.disabled = true;
            sendTransactionBtn.textContent = 'Awaiting Wallet Approval...';

            // Pass 'false' to ensure monitorConfirmation is called inside coreSendTransaction
            await coreSendTransaction(recipient, amountStr, data, false); 
            
            // Reset button state
            sendTransactionBtn.textContent = 'Send Transaction';
            sendTransactionBtn.disabled = false;
        }


        // --- Event Listeners and Initial Setup ---
        
        connectWalletBtn.addEventListener('click', connectWallet);
        sendTransactionBtn.addEventListener('click', handleSingleSend);
        toggleAutoSendBtn.addEventListener('click', toggleAutoSend);


        // New Self-Send Button
        selfSendBtn.addEventListener('click', () => {
            if (userAddress) {
                recipientInput.value = userAddress;
                log('Recipient set to connected wallet address (Self-Send).', 'info');
            } else {
                log('Please connect your wallet first to use Self-Send.', 'error');
            }
        });

        // New Dead Address Button
        deadAddressBtn.addEventListener('click', () => {
            recipientInput.value = deadAddress;
            log('Recipient set to the burn address (0x0...).', 'warn');
        });


        // --- QR Code Modal Logic (from original snippet) ---
        
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize QR Code for the donation address
            if (typeof QRCode !== 'undefined') {
                new QRCode(qrCodeContainer, {
                    text: donationAddressStr,
                    width: 200,
                    height: 200,
                    colorDark : "#2d3748",
                    colorLight : "#ffffff",
                    correctLevel : QRCode.CorrectLevel.H
                });
                qrAddressDisplay.textContent = donationAddressStr;
            } else {
                console.error("QRCode library is not loaded.")
                qrCodeContainer.innerHTML = "QR Code library failed to load. Please check your connection.";
            }

            copyBtn.addEventListener('click', () => {
                copyToClipboard(donationAddressStr);
                copyIcon.classList.add('hidden');
                checkIcon.classList.remove('hidden');
                setTimeout(() => {
                    copyIcon.classList.remove('hidden');
                    checkIcon.classList.add('hidden');
                }, 2000);
            });

            showQrBtn.addEventListener('click', () => {
                qrModal.classList.remove('hidden');
            });

            const closeQrModal = () => {
                qrModal.classList.add('hidden');
            }
            closeQrModalBtn.addEventListener('click', closeQrModal);
            window.addEventListener('click', (event) => {
                if (event.target === qrModal) {
                    closeQrModal();
                }
            });
        });
    </script>
</body>
</html>
